{"meta":{"title":"強い","subtitle":null,"description":"付大强,关于付大强,付大强个人简历,web付大强,前端付大强,大强,小强,小强精神,付大强的个人博客,前端小强,付大强的个人首页,付大强的个人中心,付大强的个人主页,打不死的小强,fudaqiang,FUDAQIANG,FDQ,小强强,强强,小鬼,淙淙","author":"強い","url":"http://fudaqiang.com"},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2019-04-08T07:10:27.253Z","comments":false,"path":"about/index.html","permalink":"http://fudaqiang.com/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... function bot_ui_ini() { var botui = new BotUI(\"hello-mashiro\"); botui.message.add({ delay: 800, content: \"Hi, there111👋\" }).then(function () { botui.message.add({ delay: 1100, content: \"这里是 Mashiro\" }).then(function () { botui.message.add({ delay: 1100, content: \"一个可爱的蓝孩子~\" }).then(function () { botui.action.button({ delay: 1600, action: [{ text: \"然后呢？ 😃\", value: \"sure\" }, { text: \"少废话！ 🙄\", value: \"skip\" }] }).then(function (a) { \"sure\" == a.value && sure(); \"skip\" == a.value && end() }) }) }) }); var sure = function () { botui.message.add({ delay: 600, content: \"😘\" }).then(function () { secondpart() }) }, end = function () { botui.message.add({ delay: 600, content: \"![...](https://view.moezx.cc/images/2018/05/06/a1c4cd0452528b572af37952489372b6.md.jpg)\" }) }, secondpart = function () { botui.message.add({ delay: 1500, content: \"目前就读于上海财经大学\" }).then(function () { botui.message.add({ delay: 1500, content: \"向往技术却误入商科，但后来喜欢上了经济学…\" }).then(function () { botui.message.add({ delay: 1200, content: \"因为数据分析也需要Coder嘛\" }).then(function () { botui.message.add({ delay: 1500, content: \"主攻 R 语言和 Python，略懂 STATA，偶尔也折腾 HTML/CSS/JavaScript/PHP\" }).then(function () { botui.message.add({ delay: 1500, content: \"研究的方向，是经济/金融方向的数据分析（data science）以及机器学习（machine learning）\" }).then(function () { botui.message.add({ delay: 1800, content: \"喜欢画画，希望有一天能够被称为画师\" }).then(function () { botui.action.button({ delay: 1100, action: [{ text: \"为什么叫Mashiro呢？ 🤔\", value: \"why-mashiro\" }] }).then(function (a) { thirdpart() }) }) }) }) }) }) }) }, thirdpart = function () { botui.message.add({ delay: 1E3, content: \"Mashiro以及站名都来自一部动画，因为和主角有一样的爱好~ 如果有兴趣可以找找首页上的视频~\" }).then(function () { botui.action.button({ delay: 1500, action: [{ text: \"为什么是白猫呢？ 🤔\", value: \"why-cat\" }] }).then(function (a) { fourthpart() }) }) }, fourthpart = function () { botui.message.add({ delay: 1E3, content: \"因为对GitHub有种执念… \" }).then(function () { botui.message.add({ delay: 1100, content: \"而且我真的是猫控！\" }).then(function () { botui.action.button({ delay: 1500, action: [{ text: \"域名有什么含意吗？(ง •_•)ง\", value: \"why-domain\" }] }).then(function (a) { fifthpart() }) }) }) }, fifthpart = function () { botui.message.add({ delay: 1E3, content: \"emmmm，看备案信息你就知道了=.= 本来想要zheng.xin的，但50万真买不起。。\" }).then(function () { botui.message.add({ delay: 1600, content: \"那么，仔细看看我的博客吧？ ^_^\" }) }) } } bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2019-04-08T07:10:27.253Z","comments":false,"path":"bangumi/index.html","permalink":"http://fudaqiang.com/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-04-08T07:10:27.254Z","comments":false,"path":"client/index.html","permalink":"http://fudaqiang.com/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-04-08T07:10:27.254Z","comments":true,"path":"comment/index.html","permalink":"http://fudaqiang.com/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-04-08T07:10:27.255Z","comments":false,"path":"lab/index.html","permalink":"http://fudaqiang.com/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-04-08T07:10:27.255Z","comments":false,"path":"donate/index.html","permalink":"http://fudaqiang.com/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-04-08T07:10:27.257Z","comments":false,"path":"video/index.html","permalink":"http://fudaqiang.com/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-04-08T07:10:27.256Z","comments":true,"path":"rss/index.html","permalink":"http://fudaqiang.com/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-04-08T07:10:27.256Z","comments":true,"path":"tags/index.html","permalink":"http://fudaqiang.com/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-04-08T07:10:27.257Z","comments":false,"path":"theme-sakura/index.html","permalink":"http://fudaqiang.com/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-04-08T11:35:47.553Z","comments":false,"path":"music/index.html","permalink":"http://fudaqiang.com/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2019-04-08T11:09:45.826Z","comments":true,"path":"links/index.html","permalink":"http://fudaqiang.com/links/index.html","excerpt":"","text":"","keywords":"友人帐"}],"posts":[{"title":"vuex","slug":"vuex","date":"2019-04-09T05:24:15.000Z","updated":"2019-04-09T05:25:26.033Z","comments":true,"path":"2019/04/09/vuex/","link":"","permalink":"http://fudaqiang.com/2019/04/09/vuex/","excerpt":"","text":"​ 一、VuexVuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态（意思就是数据），并以相应的规则保证状态以一种可预测的方式发生变化。 简单来说，vuex就是用来集中管理组件的数据的。 二、Vuex使用场合如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的 store 模式就足够您所需了。但是，如果您需要构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。引用 Redux 的作者 Dan Abramov 的话说就是： Flux 架构就像眼镜：您自会知道什么时候需要它。 1、store模式安装vuex npm i vuex -S 我们在原有项目下新建一个store.js管理Home，Goods，Users组件的数据。 其中state属性就是保存Home，Goods，Users组件所有的数据。 // store.js import Vue from &#39;vue&#39; import Vuex from &#39;vuex&#39; Vue.use(Vuex); const store = new Vuex.Store({ state: { title: &#39;首页&#39;, goodsList: [ { goodsName: &#39;苹果&#39;, price: 20 }, { goodsName: &#39;橘子&#39;, price: 22 }, { goodsName: &#39;香蕉&#39;, price: 50 }, { goodsName: &#39;菠萝&#39;, price: 43 }, ], userList: [ { userName: &#39;lvonve&#39;, age: 18 }, { userName: &#39;daotin&#39;, age: 19 }, { userName: &#39;wenran&#39;, age: 17 }, ] } }); export { store } 注意：将store.js文件导入到vue实例中： new Vue({ el: &quot;#app&quot;, components: { App }, template: `&lt;App /&gt;`, router, store }) 然后各个组件在获取数据的时候，是在computed属性中获取的，例如User组件（我们在user组件也把所有的数据都显示出来吧）： 获取的方式通过this.$store.state 的方式获取。 export let Users = { template: require(&#39;./index.html&#39;), // data() { // return { // users: [ // { name: &#39;lvonve&#39; }, // { name: &#39;daotin&#39; }, // { name: &#39;wenran&#39; }, // ] // } // }, computed: { // 这个userList就是获取到的state中的userList title: function() { return this.$store.state.title; }, userList: function() { return this.$store.state.userList; }, goodsList: function() { return this.$store.state.goodsList; } } } 然后在user组件进行显示： &lt;div&gt; &lt;h1&gt;{{title}}&lt;/h1&gt; &lt;h4&gt;用户列表&lt;/h4&gt; &lt;ul&gt; &lt;li v-for=&quot;user in userList&quot;&gt;{{user.userName}}+{{user.age}}&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;商品列表&lt;/h4&gt; &lt;ul&gt; &lt;li v-for=&quot;goods in goodsList&quot;&gt;{{goods.goodsName}}+{{goods.price}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 但是现在有个不好的地方就是，每个组件都需要使用this.$store.state来获取其中的数据，显得有些麻烦，有没有简单的办法呢？ 2、mapStatevuex提供了一个工具叫做mapState，通过它可以简化我们获取数据的方式。 mapState的作用就是返回一个对象，这个对象可以直接丢给computed。所以上面获取state的数据的方式可以写成下面的方式： import { mapState } from &#39;vuex&#39; export let Users = { template: require(&#39;./index.html&#39;), // computed: { // userList: function() { // return this.$store.state.userList; // }, // goodsList: function() { // return this.$store.state.goodsList; // } // } computed: mapState({ title(state) { return state.title; }, userList(state) { return state.userList; }, goodsList(state) { return state.goodsList; } }), } 或者你想要更简单，可以使用ES6的解构赋值： computed: mapState({ title: ({ title }) =&gt; title, userList: ({ userList }) =&gt; userList, goodsList: ({ goodsList }) =&gt; goodsList, }), 还有更简单的写法：如果state上有某个属性，可以直接赋值： computed: mapState({ title: &#39;title&#39;, userList: &#39;userList&#39;, goodsList: &#39;goodsList&#39; }), 终极写法，就是如果mapState属性的名字和state中属性的名字相同的话，就可以采用下面更简单的写法： （我们上面的例子就是mapState属性的名字和state中属性的名字相同） computed: mapState([&#39;title&#39;, &#39;goodsList&#39;, &#39;userList&#39;]) mapState使用展开符写法 一个项目中，有些时候有些mapState属性的名字和state中属性的名字相同，有些又不相同，比如下面的例子： computed: mapState({ title: &#39;title&#39;, users: &#39;userList&#39;, goods: &#39;goodsList&#39; }), 受到users和goods的拖累，title也不能写成终极进化版，这时候可以使用展开符。 ...mapState([&#39;title&#39;]) // 就类似于 mapState({ title:&#39;title&#39; }) 所以上面的例子的最终写法为： computed: { ...mapState([&#39;title&#39;]), ...mapState({ users: &#39;userList&#39;, goods: &#39;goodsList&#39; }) }, 由于我们的babel只能编译基础的ES6语法，展开符是高级ES6语法，所以还要安装一个模块： npm i babel-preset-stage-2 -D 然后在.babelrc 里面添加： { &quot;presets&quot;: [ &quot;env&quot;, &quot;stage-2&quot; ] } 使用展开符的写法还有一个好处就是可以写自己的computed计算属性，而终极写法是没办法加自己的计算属性的。所以展开符的写法是最灵活的写法。 3、mutations修改state现在有个新需求，在user组件，点击按钮，添加一个新用户（先把没用的商品列表去掉），我门一般的想法是直接操作state数据，如下： methods: { addUser() { this.$store.state.userList.push({userName: &#39;aaa&#39;,age: 9}) } } 但是这种写法是不符合store架构规范的，只能通过store提供的mutations来操作自己的state。所以我们在store中定义一个mutations属性，然后这个属性中定义一个addUser方法来添加用户，这个方法的参数指向的就是store的state属性： import Vue from &#39;vue&#39; import Vuex from &#39;vuex&#39; Vue.use(Vuex); const store = new Vuex.Store({ state: { title: &#39;我是title&#39;, goodsList: [ { goodsName: &#39;苹果&#39;, price: 20 }, { goodsName: &#39;橘子&#39;, price: 22 }, { goodsName: &#39;香蕉&#39;, price: 50 }, { goodsName: &#39;菠萝&#39;, price: 43 }, ], userList: [ { userName: &#39;lvonve&#39;, age: 18 }, { userName: &#39;daotin&#39;, age: 19 }, { userName: &#39;wenran&#39;, age: 17 }, ] }, // 添加mutations属性用来操作state数据 mutations: { addUser(state) { state.userList.push({ userName: &#39;aaa&#39;, age: 10 }); } } }); export { store } 然后在User.js中怎么调用这个addList方法呢？ 使用this.$store.commit(&#39;mutations的属性名&#39;)来调用： import { mapState } from &#39;vuex&#39; export let Users = { template: require(&#39;./index.html&#39;), computed: { ...mapState([&#39;title&#39;, &#39;userList&#39;, &#39;goodsList&#39;]) }, methods: { addUser() { // 使用commit的方式调用 this.$store.commit(&#39;addUser&#39;); } }, } 这样就可以点击按钮添加用户了。 整个应用程序，只有mutations才可以操作state状态。 但是注意： mutations中的属性，必须为纯函数，必须为同步代码。 纯函数就是传入相同的参数，得到相同的结果。 同步代码就不能是异步的，比如ajax，比如setTimeout等。 修改state时传参我们现在希望添加的用户信息自定义怎么向addUser传递参数呢？ 我们在commit的第二个参数传递数据。这里有个专业的术语叫做【载荷】 import { mapState } from &#39;vuex&#39; export let Users = { template: require(&#39;./index.html&#39;), data() { return { name: &#39;&#39;, age: 0 } }, computed: { ...mapState([&#39;title&#39;, &#39;userList&#39;, &#39;goodsList&#39;]) }, methods: { addUser() { // commit的第二个参数填写传递的载荷 this.$store.commit(&#39;addUser&#39;, { name: this.name, age: this.age }); } }, } 在store里面addUser的第二个参数接收数据： import Vue from &#39;vue&#39; import Vuex from &#39;vuex&#39; Vue.use(Vuex); const store = new Vuex.Store({ state: { title: &#39;我是title&#39;, goodsList: [ { goodsName: &#39;苹果&#39;, price: 20 }, { goodsName: &#39;橘子&#39;, price: 22 }, { goodsName: &#39;香蕉&#39;, price: 50 }, { goodsName: &#39;菠萝&#39;, price: 43 }, ], userList: [ { userName: &#39;lvonve&#39;, age: 18 }, { userName: &#39;daotin&#39;, age: 19 }, { userName: &#39;wenran&#39;, age: 17 }, ] }, mutations: { // data接收commit的载荷 addUser(state, data) { state.userList.push({ userName: data.name, age: data.age }); } } }); export { store } 3、actions除了state和mutations，store还有一个属性叫做actions。 actions里面放的就是mutations不能放的非纯函数，异步函数等。 actions里面的方法，第一个参数不是指向state，而知指向store，第二个参数还是载荷。 需要注意的是，能操作state的只有mutations，actions也不行。只能调用mutations去操作state。 举个例子，这里我们还是添加user，不过是间隔3s才写入state。 actions: { // 第一个参数指向store // 第二个参数还是载荷 addUserTimeout(cStore, data) { setTimeout(() =&gt; { cStore.commit(&#39;addUser&#39;, data); }, 3000); } } 然后在调用的时候就不能使用commit了，而是使用dispatch ： methods: { addUser() { this.$store.commit(&#39;addUser&#39;, { name: this.name, age: this.age }); }, addUserTimeout() { // 使用dispatch调用actions的属性 this.$store.dispatch(&#39;addUserTimeout&#39;, { name: this.name, age: this.age }); } }, 总结mutations与actiosn的区别： 1、commit方法用于调用mutation；dispatch 方法用于调用action； 2、mutation 函数必须是纯函数，而且不能有异步代码；action 可以不是纯函数，也可以有异步代码； 3、按照上述规则，可以用mutation完成的事情，可以直接调用mutation，mutation不能实现的事情丢给action来完成。 4、在action中，当完成异步操作，最终需要修改数据模型时，还是需要通过mutation来完成对数据模型的操作。action不允许直接操作数据模型。 4、gettersstore还有一个属性getters，相当于store的一个计算属性，就是对state的数据进行计算，当组件需要取到state的属性然后进行计算得到想要的结果的时候，计算的过程可以在getters 中进行，组件从getters中就可以直接拿到计算好的值。 这样还有一个好处就是，不仅当前组件可以拿个计算好的值，所有组件都可以拿到，如果所有组件都需要这个计算的话，那就方便多了。 举个例子：我们获取所有用户age之和： getters: { countAge(state) { let num = 0; state.userList.map(user =&gt; { num += user.age; }) return num; } } 然后在user组件里面： computed: { ...mapState([&#39;title&#39;, &#39;userList&#39;, &#39;goodsList&#39;]), // 直接调用getters的countAge属性即可 allAge() { return this.$store.getters.countAge } }, 然后页面：&lt;div&gt;age之和：&lt;/div&gt; 就会显示所有用户age之和。 和获取state值一样类似，每次获取getters的值都要使用this.$store.getters 的方式很麻烦，所以类似mapState还有mapGetters,写法和mapState一样： computed: { ...mapState([&#39;title&#39;, &#39;userList&#39;, &#39;goodsList&#39;]), ...mapGetters({ allAge: &#39;countAge&#39; }), // allAge() { // return this.$store.getters.countAge // } }, 实际上，除了有mapState，mapActions，mapMutations，mapGetters都有，且用法相同。 我们将user组件进行进行改造： methods: { // addUser() { // this.$store.commit(&#39;addUser&#39;, { // name: this.name, // age: this.age // }); // }, // addUserTimeout() { // console.log(&#39;user&#39;, this.name, this.age); // this.$store.dispatch(&#39;addUserTimeout&#39;, { // name: this.name, // age: this.age // }); // }, // 改造一 ...mapMutations({ addUser: &#39;addUser&#39; }), ...mapActions({ addUserTimeout: &#39;addUserTimeout&#39; }), // 改造二 ...mapMutations([&#39;addUser&#39;]), ...mapActions([&#39;addUserTimeout&#39;]), }, 上面的写法有个问题就是没法传递载荷？ 那么载荷在哪里传递呢？在视图中绑定点击事件时传递： 给事件加上参数，这个参数就是载荷。 &lt;div&gt; &lt;h1&gt;{{title}}&lt;/h1&gt; &lt;h4&gt;用户列表&lt;/h4&gt; &lt;div&gt;用户名：&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;&lt;/div&gt; &lt;div&gt;年龄：&lt;input type=&quot;text&quot; v-model.number=&quot;age&quot;&gt;&lt;/div&gt; &lt;!-- 原始的只有函数名 --&gt; &lt;!-- &lt;button @click=&#39;addUser&#39;&gt;添加用户&lt;/button&gt; --&gt; &lt;!-- &lt;button @click=&#39;addUserTimeout&#39;&gt;间隔3s添加用户&lt;/button&gt; --&gt; &lt;!-- 改造一 --&gt; &lt;!-- &lt;button @click=&#39;addUser({name:name,age:age})&#39;&gt;添加用户&lt;/button&gt; &lt;button @click=&#39;addUserTimeout({name:name,age:age})&#39;&gt;间隔3s添加用户&lt;/button&gt; --&gt; &lt;!-- 改造二 --&gt; &lt;button @click=&#39;addUser({name,age})&#39;&gt;添加用户&lt;/button&gt; &lt;button @click=&#39;addUserTimeout({name,age})&#39;&gt;间隔3s添加用户&lt;/button&gt; &lt;ul&gt; &lt;li v-for=&quot;user in userList&quot;&gt;{{user.userName}}+{{user.age}}&lt;/li&gt; &lt;/ul&gt; &lt;div&gt;age之和：{{allAge}}&lt;/div&gt; &lt;/div&gt; 三、store拆分如果组件特别多，每个组件的数据也就特别多，我们希望对这些数据根据不同的组件进行拆分方便管理。 现在有Home和User组件，Home组件的数据放在Home的store里面，User的数据放在User的store里面。 分别为homeStore.js和userStore.js，然后还有一个合并一起的主store叫index.js。 我们在home组件就显示一个title，user组件还是显示之前的内容。 // homeStore.js export default { state: { title: &#39;我是首页&#39;, } } // userStore.js export default { state: { title: &#39;我是用户页&#39;, userList: [ { userName: &#39;lvonve&#39;, age: 18 }, { userName: &#39;daotin&#39;, age: 19 }, { userName: &#39;wenran&#39;, age: 17 }, ] }, mutations: { addUser(state, data) { state.userList.push({ userName: data.name, age: data.age }); } }, actions: { // 第一个参数指向store // 第二个参数还是载荷 addUserTimeout(cStore, data) { setTimeout(() =&gt; { cStore.commit(&#39;addUser&#39;, data); }, 3000); } }, getters: { countAge(state) { let num = 0; state.userList.map(user =&gt; { num += user.age; }) return num; } } } 然后主store，index.js： 通过modules属性来注入各个子store import Vue from &#39;vue&#39; import Vuex from &#39;vuex&#39; import homeStore from &#39;./homeStore&#39; import userStore from &#39;./userStore&#39; Vue.use(Vuex); const store = new Vuex.Store({ modules: { home: homeStore, user: userStore } }); export { store } 然后在main.js里面vue实例中注入的就不是原先的store.js而是index.js。 由于store下的主store名字是index.js，所以不需要修改，但是要重启服务。 import Vue from &#39;vue&#39; import { router } from &#39;./router&#39; import { store } from &#39;./store&#39; import { App } from &#39;./App&#39; new Vue({ el: &#39;#app&#39;, template: &#39;&lt;App/&gt;&#39;, components: { App }, router, store }); 然后在Home.js和User.js显示这些数据： // Home.js import { mapState, mapMutations, mapActions, mapGetters } from &#39;vuex&#39; export let Home = { template: require(&#39;./index.html&#39;), computed: { ...mapState([&#39;title&#39;]) } } //User.js import { mapState, mapMutations, mapActions, mapGetters } from &#39;vuex&#39; export let Users = { template: require(&#39;./index.html&#39;), data() { return { name: &#39;&#39;, age: 0 } }, computed: { ...mapState([&#39;title&#39;, &#39;userList&#39;, &#39;goodsList&#39;]), ...mapGetters({ allAge: &#39;countAge&#39; }), }, methods: { ...mapMutations([&#39;addUser&#39;]), ...mapActions([&#39;addUserTimeout&#39;]), }, } 但是我们发现一个问题就是Home.js中的： computed: { ...mapState([&#39;title&#39;]) } 拿不到title的值，为什么呢？上面的写法相当于： computed: { ...mapState({ //title:&#39;title&#39; title: (state)=&gt;state.title; }) } 但是我们现在state里面还title吗，没有了state.home下才有title。 所以，令人沮丧的是，如果使用了store拆分，就不能使用展开符的写法了。 正确的写法是： computed: { ...mapState({ title: (state) =&gt; state.home.title; }) } User.js也是一样的。 注意： 但是对于mutations，actions，getters不会区分home和user，都会集合到一起，类似于全局的属性，所欲的组件都可以访问到，所以也就不需要加home和user前缀。 1、namespaced命名空间但是可能会存在这样一个问题，就是home和user下的mutations或者actions或者getters都有一个叫做add的方法，那么在调用的时候，调用的是谁的add呢？命名会冲突吗？ 我们可以在子store里面加一句话： namespaced:true 开启命名空间。 // homeStore.js export default { // 开启命名空间 namespaced: true, state: { title: &#39;我是首页&#39;, } } 然后获取的这些方法的时候就要加前缀home或者user： // User.js import { mapState, mapMutations, mapActions, mapGetters } from &#39;vuex&#39; export let Users = { template: require(&#39;./index.html&#39;), data() { return { name: &#39;&#39;, age: 0 } }, computed: { ...mapState({ title: (state) =&gt; state.user.title, userList: (state) =&gt; state.user.userList }), // 加user前缀 ...mapGetters({ allAge: &#39;user/countAge&#39; }), }, methods: { // 加user前缀 ...mapMutations({ addUser: &#39;user/addUser&#39; }), ...mapActions({ addUserTimeout: &#39;user/addUserTimeout&#39; }), }, } 然后还有一种写法如下，效果一样： 就是把前缀路径‘user/’提到第一个参数的位置，后面的写法和以前相同。 computed: { ...mapState({ title: (state) =&gt; state.user.title, userList: (state) =&gt; state.user.userList }), // &#39;user/&#39;提前 ...mapGetters(&#39;user/&#39;, { allAge: &#39;countAge&#39; }), }, methods: { // &#39;user/&#39;提前 ...mapMutations(&#39;user/&#39;, [&#39;addUser&#39;]), ...mapActions(&#39;user/&#39;, [&#39;addUserTimeout&#39;]), },","categories":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}]},{"title":"Vue的动画","slug":"Vue的动画","date":"2019-04-09T03:47:27.000Z","updated":"2019-04-09T05:25:42.503Z","comments":true,"path":"2019/04/09/Vue的动画/","link":"","permalink":"http://fudaqiang.com/2019/04/09/Vue的动画/","excerpt":"","text":"一、Vue的动画为什么要有动画：动画能够提高用户的体验，帮助用户更好的理解页面中的功能； Vue 中也有动画，不过远没有 css3 中的那么炫酷。只能有一些简单的变换，但是却可以配合第三方css动画库完成炫酷的变换。 1、过渡的类名在进入/离开的过渡中，会有 6 个 class 切换。 v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。 v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。 v-enter-to: 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。 v-leave: 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。 v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。 v-leave-to: 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。 要实现元素过渡，需要在添加过渡元素外边包裹上 &lt;transition&gt; &lt;/transition&gt; 闭合标签。 然后将 v-enter 和 v-leave-to 分为一组，v-enter-to 和v-leave分为一组，v-enter-active 和 v-leave-active 分为一组。 v-enter 和 v-leave-to 设置动画的起始状态； v-enter-to 和 v-leave 设置动画的结束状态； v-enter-active 和 v-leave-active 设置动画的过渡时间和过渡效果。 示例：点击按钮实现标签的淡入淡出： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .v-enter, .v-leave-to { opacity: 0; } .v-enter-active, .v-leave-active { transition: opacity 1s ease; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;显示/隐藏&quot; @click=&quot;flag=!flag&quot;&gt; &lt;transition&gt; &lt;h3 v-show=&quot;flag&quot;&gt;这是一个H3标签&lt;/h3&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#box&quot;, data: { flag: false }, methods: {} }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 注意事项： 1、发生动画的元素必须被 transition 标签包裹。 2、动画的进入离开为css属性，写在style标签中。 3、对于这些在过渡中切换的类名来说，如果你使用一个没有名字的 &lt;transition&gt;，则 v-是这些类名的默认前缀。如果你使用了 &lt;transition name=&quot;my-transition&quot;&gt;，那么 v-enter 会替换为my-transition-enter。 2、使用插件实现动画这里我们使用：Animate.css 第三方css插件。 官方网站：https://daneden.github.io/animate.css/ 使用方式： 1、引入 animate.css 库文件 2、在 tramsition 标签中使用特定动画的类样式。 &lt;transition enter-active-class=&quot;animated zoomIn&quot; leave-active-class=&quot;animated zoomOut&quot; :duration=&quot;{ enter: 200, leave: 400 }&quot;&gt; &lt;h3 v-show=&quot;flag&quot;&gt;这是一个H3标签&lt;/h3&gt; &lt;/transition&gt; 注意： 1、类样式一定要加基础类样式 animated 2、enter-active-class ：表示进入动画样式 leave-active-class：表示离开动画样式 :duration=&quot;{ enter: 200, leave: 400 }&quot;： 表示进入和离开的动画时间，单位ms。 如果只写 :duration=&quot;200&quot;则表示进入和离开的事件都为200ms。 3、半程动画有的时候我们只想实现动画的进入，不想实现动画的退出。比如将物品加入购物车的动画，会有一个商品掉入购物车的动画效果，但是我们却不需要商品再从购物车出来的动画效果，那么如何实现动画的半程效果呢？ 使用 JavaScript 钩子函数：（写在 transition 标签中） &lt;transition v-on:before-enter=&quot;beforeEnter&quot; v-on:enter=&quot;enter&quot; v-on:after-enter=&quot;afterEnter&quot; v-on:enter-cancelled=&quot;enterCancelled&quot; v-on:before-leave=&quot;beforeLeave&quot; v-on:leave=&quot;leave&quot; v-on:after-leave=&quot;afterLeave&quot; v-on:leave-cancelled=&quot;leaveCancelled&quot; &gt; &lt;!-- ... --&gt; &lt;/transition&gt; 其中上面四个事件是进如动画的几个阶段： before-enter ：动画进入之前的状态 enter：动画进入结束时的状态 after-enter：动画进入完成后的操作。 enter-cancelled：动画进入中断的操作（一般不使用） 既然是事件绑定函数，那么就有需要在 methods 中填写对应的事件处理函数： methods: { // -------- // 进入中 // -------- beforeEnter: function (el) { // ... }, enter: function (el, done) { // ... done() }, afterEnter: function (el) { // ... } 其中： 1、参数 el 表示的是需要动画操作的 原生DOM对象。 2、当只用 JavaScript 过渡的时候，在 enter 和 leave 中必须使用 done 进行回调。enter中的done参数就相当于进入动画中的 afterEnter 函数，可以避免动画完成后的延迟。 3、这些钩子函数可以结合 CSS transitions/animations 使用，也可以单独使用。 模拟商品掉入购物车过程 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .ball { width: 20px; height: 20px; border-radius: 50%; background-color: blue; margin-top: 10px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;快到碗里来&quot; @click=&quot;flag = !flag&quot;&gt; &lt;transition @before-enter=&quot;beforeEnter&quot; @enter=&quot;enter&quot; @after-enter=&quot;afterEnter&quot;&gt; &lt;div class=&quot;ball&quot; v-show=&quot;flag&quot;&gt;&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#box&quot;, data: { flag: false }, methods: { beforeEnter(el) { el.style.transform = &quot;translate(0, 0)&quot;; }, enter(el, done) { // 这句话，没有实际的作用，但是，如果不写，出不来动画效果； el.offsetWidth; el.style.transform = &quot;translate(100px, 400px)&quot;; el.style.transition = &#39;transform 1s&#39;; // 不使用的话，小圆点会停留一段时间才消失，不能立即调用 afterEnter 函数 done(); }, afterEnter(el) { this.flag = !this.flag; } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 1、enter 中的 el.offsetWidth; 无实际作用，可以认为 el.offset系列语句会强制动画刷新。 2、done(); 必须使用，相当于立即调用 afterEnter 函数。 3、既然是半程动画，那么意味着点击按钮的时候，每次小球都是从起始位置出发，而不会从终点位置回到其实位置的过程。 4、列表动画列表增加，删除项的时候，显示动画效果。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;style&gt; li { width: 100%; border: 1px dashed #aaa; margin: 10px 0; font: 700 12px/36px &#39;Microsoft YaHei&#39;; padding-left: 10px; } li:hover { border: 1px solid rgb(226, 22, 124); transition: border .5s; } /* 只对transition-group包裹的起作用*/ .v-enter, .v-leave-to { opacity: 0; transform: translateY(-10px); } .v-enter-active, .v-leave-active { transition: transform 0.5s ease-out; } /*列表的过渡更加平缓柔和*/ .v-move { transition: all 0.5s; } /*列表的过渡更加平缓柔和*/ .v-leave-active { position: absolute; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;div&gt; &lt;label for=&quot;&quot;&gt; ID: &lt;input type=&quot;text&quot; v-model=&quot;id&quot;&gt; &lt;/label&gt; &lt;label for=&quot;&quot;&gt; name: &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt; &lt;/label&gt; &lt;input type=&quot;button&quot; value=&quot;添加&quot; @click=&quot;add&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;ul&gt; &lt;!-- 1、使用transition-group包裹v-for渲染的li列表 --&gt; &lt;transition-group appear&gt; &lt;li v-for=&quot;(item, index) in list&quot; :key=&quot;item.id&quot; @click=&quot;del(index)&quot;&gt; {{item.id}} --- {{item.name}} &lt;/li&gt; &lt;/transition-group&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#box&quot;, data: { id: &#39;&#39;, name: &#39;&#39;, list: [{ id: 1, name: &#39;漩涡鸣人&#39; }, { id: 2, name: &#39;宇智波佐助&#39; }, { id: 3, name: &#39;旗木卡卡西&#39; }, { id: 4, name: &#39;自来也&#39; }, ] }, methods: { add() { this.list.push({ id: this.id, name: this.name }); }, del(id) { this.list.splice(id, 1); } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 注意： 1、在实现列表过渡的时候，如果需要过渡的元素，是通过 v-for 循环渲染出来的，不能使用 transition 包裹，需要使用 transition-group. 2、如果要为 v-for 循环创建的元素设置动画，必须为每一个 元素 设置 :key 属性 3、过渡的类名：v-enter 等，这些类只对 transition 或者 transition-group 包裹起来的元素起作用。 4、&lt;transition-group&gt; 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 v-move 特性，它会在元素的改变定位的过程中应用。实现删除动画的时候，后一个元素补到删除元素的位置也能动画，v-move 和 v-leave-active 结合使用，能够让列表的过渡更加平缓柔和： .v-move { transition: all 0.5s; } .v-leave-active { position: absolute; } 5、给 transition 或者 transition-group 添加属性：appear 可以实现页面开始加载的时候，实现动画效果。 我们发现一个问题就是，transition-group 会被默认当做 span 标签，这不是我们想要的样子鸭。 通过 为 transition-group 元素，设置 tag 属性，指定 transition-group 渲染为指定的元素，如果不指定 tag 属性，默认渲染为 span 标签，这就不符合语义了。所以我们可以把外层的 ul 去掉，然后加上tag=&quot;ul&quot;来把 transition-group 标签作为 ul 标签。","categories":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}]},{"title":"grunt","slug":"grunt","date":"2019-04-09T03:22:55.000Z","updated":"2019-04-09T03:42:56.693Z","comments":true,"path":"2019/04/09/grunt/","link":"","permalink":"http://fudaqiang.com/2019/04/09/grunt/","excerpt":"","text":"一、Grunt介绍Grunt 中文主页 : http://www.gruntjs.net/ Grunt 是一套前端自动化构建工具，一个基于nodeJs的命令行工具。 它是一个任务运行器, 配合其丰富强大的插件 注意：Grunt 不支持 ES6 语法。如果要使用，需要先转化成 ES5 语法，再使用 Grunt。 常用功能: 合并文件(js/css) 压缩文件(js/css) 语法检查(js) less/sass预编译处理 其它… 二、Grunt 使用步骤1、安装nodejs // 查看版本 node -v 2、创建一个简单的应用 grunt 项目。 下面是目录的结构： |- build----------构建生成的文件所在的文件夹 |- src------------源码文件夹 |- js---------------js源文件夹 |- css--------------css源文件夹 |- index.html-----页面文件 |- Gruntfile.js---grunt配置文件(注意首字母大写) |- package.json---项目包配置文件 { &quot;name&quot;: &quot;grunt_test&quot;, &quot;version&quot;: &quot;1.0.0&quot; } 注意：package.json 中 name 的值 只能包含小写字母数字和中划线，如果为空则使用项目文件夹名称代替。 3、安装 grunt 此命令会自动生成 node-modules 文件夹。 全局安装 grunt-cli npm install -g grunt-cli 项目安装 grunt npm install grunt --save-dev 为什么全局安装 grunt 后还要局部安装 grunt？ 全局安装的 grunt 是在命令行中用的，项目中的 grunt 是调用 插件 或者自身的命令用的，名称相同，作用不同，缺一不可。 package.json和package-lock.json的区别： 自npm 5.0版本发布以来，npm istall的规则发生了三次变化: 1.npm 5.0.x版本，不管package.json怎么变，npm install时都会根据package-lock.json下载； 2.npm 5.1.0版本后，npm install会无视package-lock.json,下载最新的版本； 3.npm 5.4.2版本后， 如果package.json与package-lock.json不一致，npm install会根据package.json去下载版本，并更新package-lock.json； 如果package.json与package-lock.json一致，npm install会根据package-lock.json去下载。 4、运行构建项目命令 grunt 提示：Fatal error: Unable to find Gruntfile. 说明我们没有添加 Gruntfile.js 文件，在执行 grunt 命令的时候，会先找 Gruntfile.js 文件，这文件里面描述的是要执行什么任务。 5、配置文件: Gruntfile.js 此配置文件本质就是一个node函数类型模块 配置编码包含3步: 初始化插件配置 加载插件任务 注册构建任务 基本编码（下面是以 uglify 插件为例），grunt 的任务执行其实并不是本身执行任务，而是调用旗下各种插件来执行各种任务。grunt 就像一个大脑一样，只是起到指挥作用: module.exports = function(grunt) { // 1、初始化插件配置 grunt.initConfig({ pkg: grunt.file.readJSON(&#39;package.json&#39;), uglify: { options: { banner: &#39;/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&gt; */\\n&#39; }, build: { src: &#39;src/&lt;%= pkg.name %&gt;.js&#39;, dest: &#39;build/&lt;%= pkg.name %&gt;.min.js&#39; } } }); // 2、加载任务的插件。 grunt.loadNpmTasks(&#39;grunt-contrib-uglify&#39;); // 3、注册构建任务 grunt.registerTask(&#39;default&#39;, [&#39;uglify&#39;]); }; 此配置可以在官网找到： 再次执行命令: grunt ——– 提示成功, 但没有任何效果(还没有使用插件定义任务，我们将其注释掉了) 三、Grunt插件grunt官网的插件列表页面 http://www.gruntjs.net/plugins 插件分类: grunt团队贡献的插件 : 插件名大都以contrib-开头 第三方提供的插件 : 大都不以contrib-开头 常用的插件: grunt-contrib-clean——清除文件(打包处理生成的) grunt-contrib-concat——合并多个文件的代码到一个文件中 grunt-contrib-uglify——压缩js文件 grunt-contrib-jshint——javascript语法错误检查； grunt-contrib-cssmin——压缩/合并css文件 grunt-contrib-htmlmin——压缩html文件 grunt-contrib-imagemin——压缩图片文件(无损) grunt-contrib-copy——复制文件、文件夹 grunt-contrib-requirejs——合并压缩requirejs管理的所有js模块文件 grunt-contrib-watch——实时监控文件变化、调用相应的任务重新执行 四、JS 插件使用1、合并js注意：每个插件在使用的时候，都需要单独下载。 下面以合并js: 使用concat插件为例： 1、下载concat插件: npm install grunt-contrib-concat --save-dev 2、编写两个js文件: src/js/test1.js (function () { function add(num1, num2) { return num1 + num2; } console.log(add(10, 20)); })(); src/js/test2.js (function () { var arr = [2,3,4].map(function (item, index) { return item+1; }); console.log(arr); })(); 3、配置: Gruntfile.js 配置任务:（这个可以在官网查到插件的使用，然后进行适当路径的修改） concat: { options: { //可选项配置 separator: &#39;;&#39; //使用;连接合并 }, build: { //此名称任意 src: [&quot;src/js/*.js&quot;], //合并哪些js文件 dest: &quot;build/js/built.js&quot; //输出的js文件 } } 加载插件: grunt.loadNpmTasks(&#39;grunt-contrib-concat&#39;); 注册任务 grunt.registerTask(&#39;default&#39;, [&#39;concat&#39;]); 执行命令: grunt concat（或者直接使用grunt，会按顺序自动执行任务列表的任务。） 2、压缩js1、下载uglify插件 npm install grunt-contrib-uglify --save-dev 2、配置: Gruntfile.js 配置任务: pkg : grunt.file.readJSON(&#39;package.json&#39;), uglify : { options: { //不是必须的 banner: &#39;/*! &lt;%= pkg.name %&gt; - v&lt;%= pkg.version %&gt; - &#39; + &#39;&lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&gt; */&#39; }, build: { files: { &#39;build/js/built-&lt;%=pkg.name%&gt;-&lt;%=pkg.version%&gt;.min.js&#39;: [&#39;build/js/built.js&#39;] } } } 加载任务: grunt.loadNpmTasks(&#39;grunt-contrib-uglify&#39;); 注册任务: grunt.registerTask(&#39;default&#39;, [&#39;concat&#39;, &#39;uglify&#39;]); 执行任务: grunt uglify（或者直接使用grunt，会按顺序自动执行任务列表的任务。先执行 concat，再执行uglify） 压缩后的文件： 上面的注释就是 uglify 里面的 options 对应的输出内容。 可以看到，我们的test1.js 直接压缩成了 console.log(30);厉害了！ 需要注意的是：直接使用grunt，会按顺序自动执行任务列表的任务。先执行 concat，再执行uglify，这就说明 Grunt 是同步执行任务的。 3、js语法检查1、下载jshint插件: npm install grunt-contrib-jshint --save-dev 2、依赖文件: .jshintrc 由于 js 语法检查，是需要指定一些规则的，这些规则都写在 .jshintrc中，所以我们要先编写好 .jshintrc文件。 { &quot;curly&quot;: true, &quot;eqeqeq&quot;: true, &quot;eqnull&quot;: true, &quot;expr&quot; : true, &quot;immed&quot;: true, &quot;newcap&quot;: true, &quot;noempty&quot;: true, &quot;noarg&quot;: true, &quot;regexp&quot;: true, &quot;browser&quot;: true, &quot;devel&quot;: true, &quot;node&quot;: true, &quot;boss&quot;: false, //不能使用未定义的变量 &quot;undef&quot;: true, //语句后面必须有分号 &quot;asi&quot;: false, //预定义不检查的全局变量 &quot;predef&quot;: [ &quot;define&quot;, &quot;BMap&quot;, &quot;angular&quot;, &quot;BMAP_STATUS_SUCCESS&quot;] } 注意：最后的注释要去掉，因为 json 里面不允许有注释。 3、修改src/js/test1.js (function () { function add(num1, num2) { return num1 + num2 } console.log(add(10, 20)); })(); 4、配置 : Gruntfile.js 配置任务: jshint : { options: { jshintrc : &#39;.jshintrc&#39; //指定配置文件 }, build : [&#39;Gruntfile.js&#39;, &#39;src/js/*.js&#39;] //指定检查的文件 } 加载任务: grunt.loadNpmTasks(&#39;grunt-contrib-jshint&#39;); 注册任务: grunt.registerTask(&#39;default&#39;, [&#39;concat&#39;, &#39;uglify&#39;, &#39;jshint&#39;]); 执行命令: grunt //提示语句后未加分号 --&gt;修改后重新编译 五、CSS 插件使用1、合并压缩css1、下载cssmin插件: npm install grunt-contrib-cssmin --save-dev 2、先编写好两个css文件: test1.css #box1 { width: 100px; height: 100px; background: red; } test2.css #box2 { width: 200px; height: 200px; background: blue; } ​ 3、配置 : Gruntfile.js 配置任务: cssmin:{ options: { shorthandCompacting: false, roundingPrecision: -1 }, build: { files: { &#39;build/css/output.min.css&#39;: [&#39;src/css/*.css&#39;] } } } 加载任务: grunt.loadNpmTasks(&#39;grunt-contrib-cssmin&#39;); 注册任务: grunt.registerTask(&#39;default&#39;, [&#39;concat&#39;, &#39;uglify&#39;, &#39;jshint&#39;, &#39;cssmin&#39;]); 执行任务: grunt //在dist/css/下生成dist.min.css 我们可以发现：cssmin 其实不止进行了压缩操作，还进行了合并操作。 六、使用watch插件之前，我们每次修改js 或者css文件之后，都会进行一次grunt 指令的操作，这样太麻烦了，有没有一种方法可以在我们丢改了js 或者css文件之后，自动进行 grunt 的操作呢？watch 插件可以做到真正的自动化构建项目。 1、下载watch插件: npm install grunt-contrib-watch --save-dev 2、配置 : Gruntfile.js 配置任务: files：表示监视的是哪些文件 tasks：表示这些文件改变后，应该执行哪些任务 options：一些配置。spawn : false；表示变量更新，只对那些修改了的源文件执行任务，而不需要把所有的任务重新执行一遍，相当于C语言单文件编译和全部编译的区别。 watch : { scripts : { files : [&#39;src/js/*.js&#39;, &#39;src/css/*.css&#39;], tasks : [&#39;concat&#39;, &#39;jshint&#39;, &#39;uglify&#39;, &#39;cssmin&#39;], options : {spawn : false} } } 加载任务: grunt.loadNpmTasks(&#39;grunt-contrib-watch&#39;); 注册任务: grunt.registerTask(&#39;default&#39;, [&#39;concat&#39;, &#39;uglify&#39;, &#39;jshint&#39;, &#39;watch&#39;]); 上面这种写法会在cmd下一直等待源文件的改变，无法停止。而我们在需要项目上线的时候，只需要执行一次任务即可，所以我们可以专门定义一个任务来监听源文件的改变，而对于需要上线的项目，只需要像之前default任务一样执行一次就好了。 改进写法： grunt.registerTask(&#39;default&#39;, [&#39;concat&#39;, &#39;uglify&#39;, &#39;jshint&#39;]); grunt.registerTask(&#39;mywatch&#39;, [&#39;default&#39;,&#39;watch&#39;]); 注意：在执行监视任务的时候，一定要先执行default的任务，否则无法完成监视任务。 执行命令： grunt mywatch //控制台提示watch已经开始监听, 修改源文件保存后会自动编译处理","categories":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}]},{"title":"Webpack","slug":"Webpack","date":"2019-04-09T02:01:13.000Z","updated":"2019-04-09T03:42:26.895Z","comments":true,"path":"2019/04/09/Webpack/","link":"","permalink":"http://fudaqiang.com/2019/04/09/Webpack/","excerpt":"","text":"##一、Webpack介绍 Webpack 中文官网 https://www.webpackjs.com/ 1、什么是webpack?Webpack是一个模块打包器(bundler)。 但是，webpack的核心功能是： 把模块化规范的代码，比如commonJS等编译成浏览器能识别的代码输出出来(也叫作前端模块化) 我们知道在之前，commonJS规范的代码只能在node后端中运行（node是原生支持commonJS模块化的），如果在前端使用的话，会报一个错误：‘require is not defined’ 找不到require，这就是模块化规范的代码不能在浏览器中解析运行，如果想运行，达到前端模块化的功能，就要使用自动化构建工具，webpack就是其中的一种。 webpack的辅助功能才是对源代码的打包，压缩，混淆处理等。 所以一定要搞清楚主次关系。 在Webpack看来, 前端的所有资源文件(js/json/css/img/less/…)都会作为模块处理，每一个资源文件都是一个模块。它将根据模块的依赖关系进行静态编译，生成对应的静态资源。 webpack所有的配置都会写在项目根目录下的webpack.config.js 文件下。 webpack如何配置，你需要先理解四个核心概念： 入口(entry) 输出(output) loader 插件(plugins) 入口 指示 webpack 应该使用哪个模块作为主模块来构建静态资源，一般打包的时候只引入主模块，而在主模块中会引入其他的模块，这样我们就只需要打包一份主模块就够了。 Loader Webpack 本身只能加载JS/JSON模块，如果要加载其他类型的文件(模块)，就需要使用对应的loader 进行转换/加载 Loader 本身也是运行在 node.js 环境中的 JavaScript 模块 它本身是一个函数，接受源文件作为参数，返回转换的结果 loader 一般以 xxx-loader 的方式命名，xxx 代表了这个 loader 要做的转换功能，比如 json-loader。 配置文件(默认) webpack.config.js : 是一个node模块，返回一个 json 格式的配置信息对象 插件 插件件可以完成一些loader不能完成的功能。 插件的使用一般是在 webpack 的配置信息 plugins 选项中指定。 CleanWebpackPlugin: 自动清除指定文件夹资源 HtmlWebpackPlugin: 自动生成HTML文件并 UglifyJSPlugin: 压缩js文件 二、webpack初体验1、安装webpack由于现在webpack版本在2018年8月份的时候更新到 webpack 4+ 了，但是市面上用的最多的还是webpack3+，所以下面所有的示例均已webpack3+来演示。 如果想要使用 webpack3+ 的版本的话，在全局安装和局部安装的时候需要注意，需要在webpack后面加上@3 ，表示安装webpack3+ 的版本。 //全局安装 npm install webpack@3.11.0 -g //局部安装 npm install webpack@3.11.0 -D 全局安装时为了能够使用webpack指令来进行项目的编译等， 项目安装是为了使用webpack模块的内容。 2、初始化项目使用npm init -y 初始化项目。 -y的目的是不提示项目名等等提示信息，直接全部使用默认的配置创建package.json文件。 创建src目录，目录下建一个主模块main.js，在主模块中调用sayHello.js文件 // sayHello.js module.exports = name =&gt; { console.log(name); } // main.js let say = require(&#39;./sayHello&#39;); say(&#39;lone&#39;); 创建主页面 将来webpack打包生成的js文件是dist目录下的index.js文件 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;真的&lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt; &lt;/html&gt; 3、编译运行webpack main.js index.js 然后就可以在浏览器中查看打印出’lone’ 三、webpack打包有的时候我们希望将编译好的js文件放到指定的dist目录，但是我们又不想手工创建，有没有办法呢？ webpack.config.js配置文件可以解决。 1、新建一个webpack.config.js文件： module.exports = { entry: __dirname + &#39;/src/main.js&#39;, output: { path: __dirname + &#39;/dist&#39;, filename: &#39;index.js&#39; } } __dirname 表示当前项目的根路径。 entry 入口模块 output 输出的目标文件的路径和文件名 2、使用指令进行编译： webpack 之后我们会在项目更目录下发现一个dist目录，目录下有个index.js文件，就是我们的目标文件。 四、热加载（自动编译）每次在我们修改源文件后，都需要进行webpack指令进行打包才可以生成目标文件，才能在页面展示使用。 有没有在源代码修改保存后，自动编译成目标位文件刷新页面呢？ 这就是webpack-dev-server模块。webpack-dev-server模块会自动开启个本地web服务器来运行我们的程序，一旦源文件被修改，会自动同步到浏览器中。 webpack-dev-server模块原理： webpack-dev-server 其实就是个微服务器，在执行 webpack-dev-server 命令的时候，也会首先从 webpack.config.js 中找到任务，然后在其自己内部进行打包，打包好了之后，并不会输出到本地，而是在其内存中有一份 index.js ，我们通过 http://localhost:3000/ 访问的其实就是其内存中的文件，这时候即使我们删除本地 index.js 也不会影响页面的显示。 并且 webpack-dev-server 会自动寻找文件的路径，所以我们不需要指定 index.js 和 大图的路径，这也是其智能的地方。 但是需要注意的是，webpack-dev-server模块不会生成目标文件，也就是不会生成dist文件夹和里面的目标文件，webpack-dev-server会将编译运行放在内存的目标文件，而不会生成到项目中。而webpack指令才可以生成目标文件。 1、安装 webpack-dev-server模块 npm i webpack-dev-server@2.9.7 -g 注意安装2.9.7版本的。 2、在webpack.config.js中进行配置： // 安装的webpack-dev-server模块配置信息 devServer: { contentBase: __dirname + &#39;/dist&#39;, // 指定本地web服务器根路径 port: 3000, inline: true // 当源文件改变后，自动在浏览器页面刷新 } 3、运行指令 webpack-dev-server --inline --open 这时候，编译完成会自动访问http://localhost:3000 地址，就不用再打开浏览器了，如果项目源代码有修改，保存后，浏览器会自动进行刷新显示。 4、这个命令太长了，package.json就用到了。 &quot;scripts&quot;: { &quot;start&quot;: &quot;webpack-dev-server --inline --open&quot;, &quot;build&quot;: &quot;webpack&quot; } 以后直接使用指令： npm run start 想生成dist文件的时候： npm run build 五、html-webpack-plugin插件我们之前编译的dist文件夹只有index.js目标文件，其实我们在项目上线的时候，除了有js文件还应该有index.html 主文件，所以我们应该把html文件放到dist目录下。但是由于一般dist下的文件不建议修改，我们希望的是修改了源文件中的html就自动复制一份到dist中，html-webpack-plugin 插件就给我们提供了帮助。 1、安装html-webpack-plugin插件 npm i html-webpack-plugin -D 2、修改webpack.config.js配置文件 let Hwp = require(&#39;html-webpack-plugin&#39;); //.. // 安装的html-webpack-plugin模块的配置 plugins: [ new Hwp({ template: __dirname + &#39;/src/index.html&#39;, // 源文件index.html路径 filename: &#39;index.html&#39;, // 由于生成路径output已配置，这里只写生成的文件名 inject: true // 在index.html中自动引入需要的就js,css文件 }) ] html-webpack-plugin插件还有个额外功能就是 inject: true，它可以自动识别需要引入的script和link文件，特别好使。 3、重启服务 六、打包css到js项目还存在css文件怎么办？可以把css样式打包到js中。 1、安装模块 css-loader和style-loader npm i css-loader style-loader -D css-loader：作用是读取css文件 style-loader：作用是将css注入到js中 2、配置config module: { rules: [{ test: /\\.css$/, // 解析以.css结尾的文件 loader: &#39;style-loader!css-loader&#39; //解析以.css结尾的文件需要用到的模块（注意：书写顺序是先使用的写后面） }] } 注意：loader: ‘style-loader!css-loader’ 中书写的顺序，先需要用到的写到后面。 3、在入口js引入css文件 // main.js require(&#39;./style/base.css&#39;); 4、重启服务 npm run start 七、打包图片文件到js1、安装插件 // 图片相关插件（url-loader是对象file-loader的上层封装，使用时需配合file-loader使用。） npm install file-loader url-loader -D 2、修改配置文件 module: { rules: [ { test: /\\.(png|jpg|gif)$/, use: [{ loader: &#39;url-loader&#39;, options: { limit: 8192 } }] } // 限制转换的图片大小为8Kb ] }, 3、在css中插入图片 div { width: 200px; height: 200px; background: url(../img/1.jpg); } 4、重新编译 我们发现dist中没有图片，但是图片显示了，说明图片注入到了css中。我们可以查看生成的index.css看出来，图片是以base64的形式存在的： div { width: 200px; height: 200px; background: url(data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAASA...（太长省略）BBHDPds2gKCBThSN3rYhi5J6mjNJ2FJSsB7Sn+cV82af8A8hGy/wCvq3/9GpX0BXFXgnM3hJ2P/9k=); } 注意：当我们设置的图片大小超过限时时，会在dist中产生一个图片，而不是base64形式的。 比如我把 limit: 1024 之后，重新webpack生成后会在dist下生成一个990384cd91d73b43929679287541587e.jpg图片，然后在css中引入的是这个图片，而不是base64。 div { width: 200px; height: 200px; background: url(990384cd91d73b43929679287541587e.jpg); } 七、开启地图资源模式之前把所有的js和css都编译到一个js里面之后，如果我们代码有运行错误，排错非常麻烦，因为生成的js文件非常长，可能报错的位置是在一万多行的位置，但是 实际上我们代码的位置只是在几十行的位置。这个该如何处理？ 这就需要我们开启地图资源模式。 开启的方式很简单，只需要在配置文件中加上下面一句话即可。 // 开启地图资源模式 devtool: &#39;source-map&#39; 此时，当我们使用webpack 生成目标文件的时候，会自动多出一个map文件，比如index.js.map 这个就是一个源文件和编译后目标文件的一个映射文件，当程序有错误的时候，提示的就是源文件的行号而不是目标文件的行号，方便错误定位。 我们可以在目标文件的最后发现有个映射文件的声明的注释，这个注释不能删除，否则就无法实现映射功能。 八、多入口文件之前的目标文件只有一个index.js，如何生成多个目标文件？ 我们需要在配置文件的entry属性配置成一个对象，这个对象有多个属性，分别对应多个目标文件。 entry: { index: __dirname + &#39;/src/main.js&#39;, goods: __dirname + &#39;/src/goods.js&#39; }, output: { path: __dirname + &#39;/dist&#39;, filename: &#39;[name].js&#39; }, entry中每个属性即为目标文件名，输出文件的[name].js中的name即为entry的属性名。 但是，现在一般都是单页面应用，所以像这种对入口文件的形式很少见了。 九、打包Less,Scss等下面以less为例。 1、安装loader npm i less-loader less -D 2、设置配置文件 module: { rules: [ {test: /\\.css$/,loader: &#39;style-loader!css-loader&#39;}, {test: /\\.less$/, loader: &#39;style-loader!css-loader!less-loader&#39; } ] }, 也是要注意书写顺序。 3、重启服务。 十、提取样式文件之前我们是把css样式打包到js文件中的，而js是使用script标签引入的页面的。 link标签与script的区别： link标签的加载时异步的，而script的加载会阻塞程序的运行，影响用户体验，所有有必要将css文件提取出来。 1、安装插件 npm i extract-text-webpack-plugin -D 2、修改配置 let Ext = require(&#39;extract-text-webpack-plugin&#39;); module: { rules: [ { test: /\\.css$/, loader: Ext.extract(&#39;css-loader&#39;) }, { test: /\\.less$/, loader: Ext.extract(&#39;css-loader!less-loader&#39;) } ] }, plugins: [ new Ext(&#39;index.css&#39;) ], 由于不需要注入到js中了，所以style-loader就去掉了，但读取less和css还是需要的，顺序也是需要的。 在plugins中也要new Ext，参数为生成的css目标文件名。 十一、ES6转换成ES5很多时候我们需要将ES6语法转换成ES5的，因为很多浏览器比如政府网站都比较老旧，不支持ES6语法。所以需要将ES6转换成ES5。 1、安装插件 npm i babel-loader@7.1.5 babel-core babel-preset-env -D 这三个插件： babel-loader@7.1.5 ：是一个babel工具 babel-core ：是工具的依赖 babel-preset-env：专门用来解析ES6到ES5的 2、修改配置文件 module: { rules: [ { test: /\\.css$/, loader: Ext.extract(&#39;css-loader&#39;) }, { test: /\\.less$/, loader: Ext.extract(&#39;css-loader!less-loader&#39;) }, { test: /\\.js$/, exclude: /node_modules/, loader: &#39;babel-loader?presets[]=env&#39; } ] }, exclude:除去node-modules文件夹里面的js文件 我们在loader:babel-loader中加了参数?presets[]=env，这只是临时写法。 一般写法是在项目根目录新建一个文件.babelrc: { &quot;presets&quot;:[&quot;env&quot;] } 和上面是等价的。 如果使用到ES6的高级语法，比如展开符...时，上面的插件就满足不了了，需要另一个插件： npm i babel-preset-stage-2 -D 然后修改.babelrc : { &quot;presets&quot;:[&quot;env&quot;, &quot;stage-2&quot;] } 3、在main.js书写测试代码 let obj = { name: &#39;daotin&#39;, age: 18 } let { name: user, age } = obj; console.log(user, age); 4、重启服务 十二、使用jquery方式一：在线cdn 方式二：下载jq，然后在html引入 方式三：安装插件 1、安装jq插件 npm i jquery -S 2、然后那个js文件需要，直接require引入 let $ = require(&#39;jquery&#39;); 这种方式有个缺陷就是，只能本文件使用jq，其他文件要使用，还得require一次，很多文件使用jq就得很多文件require，可不可以只引入一次所有的js都可用呢？ 3、设置jq全局作用域 let webpack = require(&#39;webpack&#39;); plugins: [ new webpack.ProvidePlugin({ $: &#39;jquery&#39; }) ], 4、重启服务即可。 ##十二、其他插件 webpack 插件： https://www.webpackjs.com/plugins/ https://webpack.docschina.org/plugins/ 1、常用的插件 使用html-webpack-plugin根据模板html生成新的html文件，并自动引入js文件到页面 使用clean-webpack-plugin清除dist文件夹 使用uglifyjs-webpack-plugin压缩打包的js文件 2、使用步骤1、下载 npm install --save-dev html-webpack-plugin clean-webpack-plugin uglifyjs-webpack-plugin 2、配置 const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); const CleanWebpackPlugin = require(&#39;clean-webpack-plugin&#39;); const UglifyJsPlugin = require(&#39;uglifyjs-webpack-plugin&#39;); module.exports = { entry: &#39;./src/js/entry.js&#39;, // 入口文件 output: { // 略 }, module: { // 略 }, devServer: { // 略 }, plugins: [ // template 表示模板的意思，表示以 &#39;./index.html&#39; 为模板创建一个html文件 // 新创建的html文件默认会生成在dist/js目录下，并自动引入bundle.js文件到页面 new HtmlWebpackPlugin({template: &#39;./index.html&#39;}), // 在打包的时候，先清空dist目录下的所有文件再生成相关文件 new CleanWebpackPlugin([&#39;dist&#39;]), // 将生成的bundle.js压缩 new UglifyJsPlugin() ] }; 3、打包运行项目 webpack 结果在 dist/js下自动生成index.html文件，并且自动引入bundle.js文件。","categories":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}]},{"title":"Gulp","slug":"Gulp","date":"2019-04-09T01:24:39.000Z","updated":"2019-04-09T03:42:57.469Z","comments":true,"path":"2019/04/09/Gulp/","link":"","permalink":"http://fudaqiang.com/2019/04/09/Gulp/","excerpt":"","text":"一、Gulp介绍Gulp 中文主页: http://www.gulpjs.com.cn/ gulp是与grunt功能类似的前端项目构建工具, 也是基于Nodejs的自动任务运行器 。能自动化地完成 javascript/coffee/sass/less/html/image/css 等文件的合并、压缩、检查、监听文件变化、浏览器自动刷新、测试等任务。 gulp比Grunt更加高效，Gulp是基于异步多任务的处理方式，而 Grunt 则是同步的任务处理方式。使得Gulp 更易于使用。 注意：Gulp 也不支持 ES6 语法。 二、Gulp使用步骤由于 Gulp 也是基于 node.js 的，所以首先要确保安装了 node.js. 1、安装 nodejs, 查看版本: node -v 2、创建一个简单的应用 gulp_test 下面为gulp_test项目的目录结构： |- dist ---- 存放项目上线的文件 |- src |- js |- css |- less |- index.html |- gulpfile.js-----gulp配置文件 |- package.json { &quot;name&quot;: &quot;gulp_test&quot;, &quot;version&quot;: &quot;1.0.0&quot; } 3、安装gulp 全局安装gulpnpm install gulp -g 局部安装gulpnpm install gulp --save-dev 4、配置编码:gulpfile.js 注意：gulpfile.js 不需要首字母大写，而 Gruntfile.js 需要首字母大写。 //引入gulp模块 var gulp = require(&#39;gulp&#39;); //定义默认任务 gulp.task(&#39;任务名&#39;, function() { // 将你的任务的任务代码放在这 }); gulp.task(&#39;default&#39;, [&#39;任务&#39;])//异步执行 5、构建命令 gulp 任务名 三、Gulp插件Gulp 同 Grunt 一样，Culp 本身是不会执行任务的，执行任务的都是小弟，也就是gulp下的插件。 注意：查找gulp的插件，需要切换到gulp国外官网，然后点击 plugins 选项，才可以查看查找相关插件。 相关插件: gulp-concat : 合并文件(js/css) gulp-uglify : 压缩js文件 gulp-rename: 文件重命名 gulp-less : 编译less gulp-clean-css : 压缩css gulp-livereload : 实时自动编译刷新 重要API gulp.src(filePath/pathArr) : 指向指定路径的所有文件, 返回文件流对象。用于读取文件。 gulp.dest(dirPath/pathArr) ：指向指定的所有文件夹。用于向文件夹中输出文件。 gulp.task(name, [deps], fn) ：定义一个任务 gulp.watch() ：监视文件的变化 四、插件使用1、合并压缩js1、创建js文件 src/js/test1.js(function () { function add(num1, num2) { return num1 + num2; } console.log(add(10, 30)); })(); src/js/test2.js(function () { var arr = [2,3,4].map(function (item, index) { return item+1; }); console.log(arr); })(); 2、下载相应插件: npm install gulp-concat gulp-uglify gulp-rename --save-dev 3、配置 gulpfile.js // 引入gulp模块 var gulp = require(&quot;gulp&quot;); //引入gulp插件 var concat = require(&quot;gulp-concat&quot;); var uglify = require(&quot;gulp-uglify&quot;); var rename = require(&quot;gulp-rename&quot;); gulp.task(&#39;js&#39;, function () { return gulp.src(&#39;src/js/*.js&#39;) // 引入js源文件 .pipe(concat(&#39;build.js&#39;)) // 合并为临时js文件build.js .pipe(gulp.dest(&#39;dist/js/&#39;)) // 输出到dist/js目录下 .pipe(uglify()) // 将临时js文件压缩 .pipe(rename({ // 将压缩后的js文件添加.min后缀（重命名为build.min.js） suffix: &#39;.min&#39; })) .pipe(gulp.dest(&#39;dist/js/&#39;)); // 再将最终的build.min.js输出到dist/js目录下 }); gulp.task(&#39;default&#39;, [&#39;js&#39;]); 1、插件的引入不同于gulp模块的引入，gulp 的引入之后，gulp是个对象，可以点出task等任务，但是插件引入之后是个方法，既然是方法，就可以直接加括号来调用，此为区别，需要注意。 2、gulp.src 引入源文件的时候，如果 js目录 下面还有目录，这个目录里面也有js文件，如果想递归引入src里面所有的js可以这样写：src/js/**/*.js ，给 js 目录下面套上一个 ** 目录就递归查找 js目录下所有的js文件。 3、.pipe 是管道操作，用来链接任务的执行流。 4、rename 方法里面可以直接填写 build.min.js 来指定文件名，也可以使用一个对象，其键为 suffix 表示后缀名的意思，值为 .min 表示后缀名为 .min，但是这里面的后缀名是除开 .js 后缀的，最后在文件名的最后还会加上.js的。 5、return 的作用：使得grup的任务执行为异步的，就这一点，非常重要。 4、页面引入 js 浏览测试 &lt;script type=&quot;text/javascript&quot; src=&quot;dist/js/built.min.js&quot;&gt;&lt;/script&gt; 2、合并压缩css/less1、创建less/css文件 src/css/test1.css#div1 { width: 100px; height: 100px; background: green; } src/css/test2.css#div2 { width: 200px; height: 200px; background: blue; } src/less/test3.less@base: yellow; .index1 { color: @base; } .index2 { color: green; } 2、下载插件 npm install gulp-less gulp-clean-css --save-dev 3、配置gulpfile.js var less = require(&#39;gulp-less&#39;); var cleanCSS = require(&#39;gulp-clean-css&#39;); //less处理任务 gulp.task(&#39;lessTask&#39;, function () { return gulp.src(&#39;src/less/*.less&#39;) .pipe(less()) .pipe(gulp.dest(&#39;src/css/&#39;)); }) //css处理任务, 指定依赖的任务 gulp.task(&#39;cssTask&#39;,[&#39;lessTask&#39;], function () { return gulp.src(&#39;src/css/*.css&#39;) .pipe(concat(&#39;built.css&#39;)) .pipe(gulp.dest(&#39;dist/css/&#39;)) .pipe(rename({suffix: &#39;.min&#39;})) .pipe(cleanCSS({compatibility: &#39;ie8&#39;})) // 为了兼容IE8浏览器 .pipe(gulp.dest(&#39;dist/css/&#39;)); }); gulp.task(&#39;default&#39;, [&#39;minifyjs&#39;, &#39;cssTask&#39;]); 有个问题： 1、我们知道，grup是异步执行的，那么上面的 less任务和 css任务会异步执行，但是有这个情况就是 less任务量非常大，事件消耗长，而css任务很小，那么有可能 css执行完了 less还没有执行完，也就没有生成 css 任务需要的 css文件，这个时候 css的任务执行就没有包括 less生成的 css文件，相当于 less的任务白做了。 2、所以，为了保证任务的执行先后，grup也可以同步执行，在gulp.task中传入一个数组，里面是处理当前任务所要依赖的任务，只有依赖的任务完成之后，才会执行当前任务。 3、所以，grup其实可以同步可以异步，但是它的异步才是它最大的卖点。 4、页面引入css测试 &lt;link rel=&quot;stylesheet&quot; href=&quot;dist/css/built.min.css&quot;&gt; &lt;div id=&quot;div1&quot; class=&quot;index1&quot;&gt;div1111111&lt;/div&gt; &lt;div id=&quot;div2&quot; class=&quot;index2&quot;&gt;div2222222&lt;/div&gt; 3、压缩html1、下载插件 npm install gulp-htmlmin --save-dev 2、配置gulpfile.js var htmlmin = require(&#39;gulp-htmlmin&#39;); //压缩html任务 gulp.task(&#39;htmlMinify&#39;, function() { return gulp.src(&#39;index.html&#39;) .pipe(htmlmin({collapseWhitespace: true})) // 去除多余的空格 .pipe(gulp.dest(&#39;dist/&#39;)); }); gulp.task(&#39;default&#39;, [&#39;minifyjs&#39;, &#39;cssTask&#39;, &#39;htmlMinify&#39;]); 3、修改页面引入路径 &lt;link rel=&quot;stylesheet&quot; href=&quot;css/built.min.css&quot;&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/built.min.js&quot;&gt;&lt;/script&gt; 4、半自动编译我们在 grunt 中有个watch插件，可以实时监视源文件的变化，那么在 gulp中也有类似的插件，叫做gulp-livereload 。 1、下载插件 npm install gulp-livereload --save-dev 2、配置gulpfile.js var livereload = require(&#39;gulp-livereload&#39;); //每个任务的最后都应该加上下面这一句 .pipe(livereload()); gulp.task(&#39;watch&#39;, [&#39;default&#39;], function () { //开启监视 livereload.listen(); //监视指定的文件, 并指定对应的处理任务 gulp.watch(&#39;src/js/*.js&#39;, [&#39;minifyjs&#39;]) gulp.watch([&#39;src/css/*.css&#39;,&#39;src/less/*.less&#39;], [&#39;cssTask&#39;,&#39;lessTask&#39;]); }); 注意： 1、watch 任务执行代码，一定要先执行 default 任务，也就是要把 default 作为 watch 任务的依赖。 2、在default里的每个任务的最后要接一个管道.pipe(livereload());来保证源文件修改后执行watch任务后，重新刷新到页面。 5、全自动编译上面半自动编译的过程，我们可以看到在我们对源码编译保存后，还需要手动刷新浏览器，能不能在我修改源文件保存后自动刷新到浏览器显示呢？ 1、下载插件gulp-connect npm install gulp-connect --save-dev 2、配置 gulpfile.js var connect = require(&quot;gulp-connect&quot;); //每个任务的最后都应该加上下面这一句 .pipe(connect.reload()); // 全自动任务 gulp.task(&#39;server&#39;, [&#39;default&#39;], function () { connect.server({ // 最后要生成的源文件的路径 root: &#39;dist/&#39;, // 开启实时刷新 livereload: true, // 开启服务器的端口号 port: 1000 }); // 监视的源文件 gulp.watch(&#39;src/js/*.js&#39;, [&#39;js&#39;]); gulp.watch([&#39;src/css/*.css&#39;, &#39;src/less/*.less&#39;], [&#39;css&#39;]); }); 问题：每次我还是要复制链接http://localhost:1000/ 到浏览器打开网页查看，还是很麻烦哦，能不能自动打开网页？^_^ 0.o 额你也太懒了….不过我还是有办法解决的。 1、下载插件：open npm install open --save-dev 2、配置（只需要加上一句open(你的链接);） var open = require(&quot;open&quot;); gulp.task(&#39;server&#39;, [&#39;default&#39;], function () { connect.server({ // 最后要生成的源文件的路径 root: &#39;dist/&#39;, // 开启实时刷新 livereload: true, // 开启服务器的端口号 port: 1000 }); // 自动打开链接 open(&quot;http://localhost:1000/&quot;); // 监视的源文件 gulp.watch(&#39;src/js/*.js&#39;, [&#39;js&#39;]); gulp.watch([&#39;src/css/*.css&#39;, &#39;src/less/*.less&#39;], [&#39;css&#39;]); }); 五、插件打包加载插件打包加载的好处是，我们不需要每次在 gulpfile.js 的开始定义插件的方法，而是用一个对象，这个对象的属性中包含所有用到的插件的方法。 1、将所有需要的插件都下载好。 npm install gulp-concat gulp-uglify gulp-rename gulp-clean-css gulp-connect gulp-htmlmin gulp-less gulp-livereload open --save-dev 2、下载打包插件： gulp-load-plugins npm install gulp-load-plugins --save-dev 3、在gulpfile.js引入 var $ = require(&#39;gulp-load-plugins&#39;)(); 注意：引入的插件是个方法，调用之后的返回值就是我们需要的对象，这个对象中包含之前引入的所有插件的方法，以后用到哪个插件的方法，直接使用 $.方法 的方式即可。 var gulp = require(&quot;gulp&quot;); var $ = require(&quot;gulp-load-plugins&quot;)(); // var concat = require(&quot;gulp-concat&quot;); // var uglify = require(&quot;gulp-uglify&quot;); // var rename = require(&quot;gulp-rename&quot;); // var less = require(&quot;gulp-less&quot;); // var cleanCss = require(&quot;gulp-clean-css&quot;); // var htmlmin = require(&quot;gulp-htmlmin&quot;); // var livereload = require(&quot;gulp-livereload&quot;); // var connect = require(&quot;gulp-connect&quot;); var open = require(&quot;open&quot;); // 合并压缩js gulp.task(&#39;js&#39;, function () { return gulp.src(&#39;src/js/*.js&#39;) .pipe($.concat(&#39;build.js&#39;)) .pipe(gulp.dest(&#39;dist/js/&#39;)) .pipe($.uglify()) .pipe($.rename({ suffix: &#39;.min&#39; })) .pipe(gulp.dest(&#39;dist/js/&#39;)) .pipe($.livereload()) .pipe($.connect.reload()); }); // less编译为css gulp.task(&#39;less&#39;, function () { return gulp.src(&quot;src/less/*.less&quot;) .pipe($.less()) .pipe(gulp.dest(&quot;src/css/&quot;)) .pipe($.livereload()) .pipe($.connect.reload()); }); // css合并压缩 gulp.task(&#39;css&#39;, [&#39;less&#39;], function () { return gulp.src(&#39;src/css/*.css&#39;) .pipe($.concat(&quot;build.css&quot;)) .pipe(gulp.dest(&#39;dist/css/&#39;)) .pipe($.cleanCss({ compatibility: &#39;ie8&#39; })) .pipe($.rename({ suffix: &#39;.min&#39; })) .pipe(gulp.dest(&#39;dist/css/&#39;)) .pipe($.livereload()) .pipe($.connect.reload()); }); // html压缩 gulp.task(&#39;html&#39;, function () { return gulp.src(&#39;index.html&#39;) .pipe($.htmlmin({ collapseWhitespace: true })) .pipe(gulp.dest(&#39;dist/&#39;)) .pipe($.livereload()) .pipe($.connect.reload()); }); // 半自动编译 gulp.task(&#39;watch&#39;, [&#39;default&#39;], function () { $.livereload.listen(); gulp.watch(&#39;src/js/*.js&#39;, [&#39;js&#39;]); gulp.watch([&#39;src/css/*.css&#39;, &#39;src/less/*.less&#39;], [&#39;css&#39;]); }); // 全自动编译 gulp.task(&#39;server&#39;, [&#39;default&#39;], function () { $.connect.server({ // 最后要生成的源文件的路径 root: &#39;dist/&#39;, // 开启实时刷新 livereload: true, // 开启服务器的端口号 port: 1000 }); // 自动打开链接 open(&quot;http://localhost:1000/&quot;); // 监视的源文件 gulp.watch(&#39;src/js/*.js&#39;, [&#39;js&#39;]); gulp.watch([&#39;src/css/*.css&#39;, &#39;src/less/*.less&#39;], [&#39;css&#39;]); }); gulp.task(&#39;default&#39;, [&#39;js&#39;, &#39;less&#39;, &#39;css&#39;, &#39;html&#39;]); 注意： 1、gulp-load-plugins 中没有 open 方法，open插件需要单独引入。 2、$ 包含的方法有个规律，就是它的方法的命名一般都是插件的除去grup的剩下单词的组合，比如 gulp-rename 插件对应的方法，在$对象中就是 $.less ，gulp-clean-css 插件比较特殊，因为后面两个单词，所以在 $ 中的方法遵循驼峰命名法，就是 $.cleanCss 。","categories":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}]},{"title":"Vue指令","slug":"Vue指令","date":"2019-04-08T14:16:33.000Z","updated":"2019-04-09T03:39:25.889Z","comments":true,"path":"2019/04/08/Vue指令/","link":"","permalink":"http://fudaqiang.com/2019/04/08/Vue指令/","excerpt":"","text":"Vue 指令1、插值表达式插值表达式就是以双重大括号 ，类似 { {msg} } 的形式插入到 html 代码中。 1、插值表达式还可以进行简单的运算（比如加减乘除等），但是不能完全放置js代码。 2、插值表达式只能放在标签之间，而不能放在标签内部。 2、v-cloak在 使用 {{ msg }} 的方式插入数据的时候，如果网速特别慢的话， {{ msg } } 所代表的值不会立即显示出来，而会显示 这个字符串本身，怎么解决这个问题呢？ 使用 v-cloak 和 CSS 表达式结合，能够解决插值表达式闪烁的问题，这样会在网络未加载完时，不显示字符串本身。 示例： &lt;style&gt; [v-cloak] { display: none; } &lt;/style&gt; ... &lt;p v-cloak&gt; {`{ msg }`} &lt;/p&gt; 3、v-text默认 v-text 是没有闪烁问题的，但是 v-text 会覆盖元素中原本的内容，而 v-cloak 只会替换插值表达式，不会把 整个元素的内容清空。 &lt;span v-text=&quot;msg&quot;&gt;&lt;/span&gt; 4、v-htmlv-text 知识插入的纯文本格式内容，而 v-html 可以插入为 html 标签的代码，并解析出来。 &lt;span v-html=&quot;msg&quot;&gt;&lt;/span&gt; ... data: { msg: &#39;&lt;h1&gt;哈哈，我是一个大大的H1， 我大，我骄傲&lt;/h1&gt;&#39; }, 5、v-bindv-bind 是 Vue中，提供的用于绑定属性的指令。将一个属性的值变成动态值。 注意： v-bind: 指令可以被简写为: &lt;input type=&quot;button&quot; value=&quot;按钮&quot; v-bind:title=&quot;mytitle + &#39;123&#39;&quot;&gt; ... data: { mytitle: &#39;这是一个自己定义的title&#39; }, title 里面的内容就不是字符串了，而是会将 data 中的变量进行替换得到一个字符串整体。 6、v-onv-on ：给某个元素绑定事件监听函数。注意，函数必须封装在methods内。 注意：v-on: 指令可以被简写为@ &lt;input type=&quot;button&quot; value=&quot;按钮&quot; :title=&quot;mytitle + &#39;123&#39;&quot; v-on:click=&quot;show&quot;&gt; ... data: { mytitle: &#39;这是一个自己定义的title&#39; }, methods: { // 这个 methods属性中定义了当前Vue实例所有可用的方法 show: function () { alert(&#39;Hello&#39;) } } 案例：字体滚动播放 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;摇起来&quot; id=&quot;btn1&quot; @click=&quot;move&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;停下来&quot; id=&quot;btn2&quot; @click=&quot;stop&quot;&gt; &lt;h2 v-text=&quot;msg&quot;&gt;&lt;/h2&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#box&quot;, data: { msg: &quot;落霞与孤鹜齐飞，秋水共长天一色。&quot;, timeId: null }, methods: { move: function () { if (this.timeId != null) { clearInterval(this.timeId); } var that = this; this.timeId = setInterval(function () { var start = that.msg.substring(0, 1); var end = that.msg.substring(1); that.msg = end + start; }, 200); }, stop: function () { clearInterval(this.timeId); } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 注意： 1、在 VM 对象实例中，如果想要获取 data 上的数据，或者 想要调用 methods 中的 方法，必须通过 this.数据属性名 或 this.方法名 来进行访问，这里的 this，就表示 我们 new 出来的 VM 实例对象。 2、VM实例，会自动监听自己身上 data 中所有数据的改变，只要数据一发生变化，就会自动把最新的数据，从data 上同步到页面中去；【好处：程序员只需要关心数据，不需要考虑如何重新渲染DOM页面】 7、v-modelv-bind 只能实现数据的单向绑定，从 M 自动绑定到 V（即修改 data 的数据，自动同步到 html）， 无法实现数据的双向绑定。 使用 v-model 指令，可以实现 表单元素和 Model 中数据的双向数据绑定（不仅可以修改 data 的数据，自动同步到 html，也可以修改 html 的代码，同步到 data 数据）。 注意： v-model 只能运用在 表单元素中。 示例： &lt;input type=&quot;text&quot; style=&quot;width:100%;&quot; v-model=&quot;msg&quot;&gt; ... data: { msg: &#39;hello vue.&#39; }, 案例：简单的计算器 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;n1&quot;&gt; &lt;select v-model=&quot;opt&quot;&gt; &lt;option value=&quot;+&quot;&gt;+&lt;/option&gt; &lt;option value=&quot;-&quot;&gt;-&lt;/option&gt; &lt;option value=&quot;*&quot;&gt;*&lt;/option&gt; &lt;option value=&quot;/&quot;&gt;/&lt;/option&gt; &lt;/select&gt; &lt;input type=&quot;text&quot; v-model=&quot;n2&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;=&quot; @click=&quot;calc&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;result&quot;&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: &#39;#app&#39;, data: { n1: 0, n2: 0, result: 0, opt: &#39;+&#39; }, methods: { calc: function() { // 计算器算数的方法 // 逻辑： switch (this.opt) { case &#39;+&#39;: this.result = parseFloat(this.n1) + parseFloat(this.n2) break; case &#39;-&#39;: this.result = parseFloat(this.n1) - parseFloat(this.n2) break; case &#39;*&#39;: this.result = parseFloat(this.n1) * parseFloat(this.n2) break; case &#39;/&#39;: this.result = parseFloat(this.n1) / parseFloat(this.n2) break; } } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 8、v-for8.1、v-for 循环普通数组 我们之前如果要循环赋值给 p 标签 data中 list=[1,2,3,4,5,6]; 数组的话，会这样写： &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;{{list[0]}}&lt;/p&gt; &lt;p&gt;{{list[1]}}&lt;/p&gt; &lt;p&gt;{{list[2]}}&lt;/p&gt; &lt;p&gt;{{list[3]}}&lt;/p&gt; &lt;p&gt;{{list[4]}}&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { list: [1, 2, 3, 4, 5, 6] }, methods: {} }); &lt;/script&gt; &lt;/body&gt; 这样的话，就会很繁琐。而 v-for 会提供循环遍历 list 数组来给 p 标签赋值。如下： &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p v-for=&quot;(item, i) in list&quot;&gt;索引：{{i}} --- 项：{{item}}&lt;/p&gt; &lt;!-- 索引：0 --- 项：1 索引：1 --- 项：2 索引：2 --- 项：3 索引：3 --- 项：4 索引：4 --- 项：5 索引：5 --- 项：6 --&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { list: [1, 2, 3, 4, 5, 6] }, methods: {} }); &lt;/script&gt; &lt;/body&gt; 8.2、v-for 循环对象数组 &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p v-for=&quot;(user, i) in list&quot;&gt;Id：{{ user.id }} --- 名字：{{ user.name }} --- 索引：{{i}}&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { list: [ { id: 1, name: &#39;zs1&#39; }, { id: 2, name: &#39;zs2&#39; }, { id: 3, name: &#39;zs3&#39; }, { id: 4, name: &#39;zs4&#39; } ] }, methods: {} }); &lt;/script&gt; &lt;/body&gt; 8.3、v-for 循环对象 &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 注意：在遍历对象身上的键值对的时候， 除了 有 val key ,在第三个位置还有 一个 索引 --&gt; &lt;p v-for=&quot;(val, key, i) in user&quot;&gt;值是： {{ val }} --- 键是： {{key}} -- 索引： {{i}}&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { user: { id: 1, name: &#39;Tony Stark&#39;, gender: &#39;男&#39; } }, methods: {} }); &lt;/script&gt; &lt;/body&gt; 8.4、v-for 循环数字 &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- in 后面我们放过普通数组，对象数组，对象，还可以放数字 --&gt; &lt;p v-for=&quot;count in 10&quot;&gt;这是第 {{ count }} 次循环&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: &#39;#app&#39;, data: {}, methods: {} }); &lt;/script&gt; &lt;/body&gt; 注意：如果使用 v-for 迭代数字的话，前面的 count 值从 1 开始。 8.5、v-for 循环 key 属性 key 属性可以使得每一遍历的项是唯一的。 &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;label&gt;Id: &lt;input type=&quot;text&quot; v-model=&quot;id&quot;&gt; &lt;/label&gt; &lt;label&gt;Name: &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt; &lt;/label&gt; &lt;input type=&quot;button&quot; value=&quot;添加&quot; @click=&quot;add&quot;&gt; &lt;/div&gt; &lt;!-- 注意： v-for 循环的时候，key 属性只能使用 number或者string --&gt; &lt;!-- 注意： key 在使用的时候，必须使用 v-bind 属性绑定的形式，指定 key 的值 --&gt; &lt;!-- 在组件中，使用v-for循环的时候，或者在一些特殊情况中，如果 v-for 有问题，必须在使用 v-for 的同时，指定 唯一的 字符串/数字 类型 :key 值 --&gt; &lt;p v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt;{{item.id}} --- {{item.name}} &lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: &#39;#app&#39;, data: { id: &#39;&#39;, name: &#39;&#39;, list: [ { id: 1, name: &#39;李斯&#39; }, { id: 2, name: &#39;嬴政&#39; }, { id: 3, name: &#39;赵高&#39; }, { id: 4, name: &#39;韩非&#39; }, { id: 5, name: &#39;荀子&#39; } ] }, methods: { add() { // 添加方法 this.list.unshift({ id: this.id, name: this.name }) } } }); &lt;/script&gt; &lt;/body&gt; 9、v-if/v-showv-if 和 v-show 都可以控制元素的显示与否。但是实现原理不同。 v-if：决定某些元素是否存在 (加载性能更高,某个元素不需要被频繁切换时,则应该使用v-if) v-show：决定某些元素是否显示 (操作性能更高,如果某个元素需要被频繁切换,则应该使用v-show) v-if：每次都会重新删除或创建元素。 v-show ： 每次不会重新进行DOM的删除和创建操作，只是切换了元素的 display:none 样式。 所以，如果元素涉及到频繁的切换，最好不要使用 v-if, 而是推荐使用 v-show； 如果元素可能永远也不会被显示出来被用户看到，则推荐使用 v-if。 &lt;h3 v-if=&quot;true&quot;&gt;这是用v-if控制的元素&lt;/h3&gt; &lt;h3 v-show=&quot;true&quot;&gt;这是用v-show控制的元素&lt;/h3&gt; 有了v-if就有v-else-if和v-else v-if和v-show指令中除了可以放简单的值外，还可以放表达式： &lt;h3 v-if=&quot;age &lt; 18&quot;&gt;这是用v-if控制的元素&lt;/h3&gt; &lt;!--age是data中的一个属性--&gt; &lt;h3 v-else-if=&quot;age &lt; 28&quot;&gt;这是用v-if控制的元素&lt;/h3&gt; &lt;h3 v-else&gt;这是用v-if控制的元素&lt;/h3&gt; &lt;!--v-else不用写条件--&gt; 注意：v-if和v-else-if和v-else之间，不要加任何其他元素，否则会报错。","categories":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}]},{"title":"严格模式","slug":"严格模式","date":"2019-04-08T14:16:33.000Z","updated":"2019-04-09T01:17:59.137Z","comments":true,"path":"2019/04/08/严格模式/","link":"","permalink":"http://fudaqiang.com/2019/04/08/严格模式/","excerpt":"","text":"一、ECMAScript 5 严格模式1、概述除了正常运行模式，ECMAscript 5添加了第二种运行模式：”严格模式”（strict mode）。顾名思义，这种模式使得Javascript在更严格的条件下运行。 2、目的 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的Javascript做好铺垫。 “严格模式”体现了Javascript更合理、更安全、更严谨的发展方向，包括IE 10在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱它。 另一方面，同样的代码，在”严格模式”中，可能会有不一样的运行结果；一些在”正常模式”下可以运行的语句，在”严格模式”下将不能运行。掌握这些内容，有助于更细致深入地理解Javascript，让你变成一个更好的程序员。 3、使用1、将”use strict”放在脚本文件的第一行，则整个脚本都将以”严格模式”运行。如果这行语句不在第一行，则无效，整个脚本以”正常模式”运行。如果不同模式的代码文件合并成一个文件，这一点需要特别注意。 (严格地说，只要前面不是产生实际运行结果的语句，”use strict”可以不在第一行，比如直接跟在一个空的分号后面。) &lt;script&gt; &quot;use strict&quot;; //... &lt;/script&gt; 2、针对单个函数 将”use strict”放在函数体的第一行，则整个函数以”严格模式”运行。 function strict(){ &quot;use strict&quot;; return &quot;这是严格模式。&quot;; } 二、语法和行为改变1、全局变量必须用var显示声明变量在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。 &lt;script type=&quot;text/javascript&quot;&gt; &quot;use strict&quot;; v = 1; // 报错，v未声明 //name = &quot;Daotin&quot;; for (i = 0; i &lt; 2; i++) { // 报错，i未声明 } &lt;/script&gt; 不能使用 name，因为 name 是window的一个保留属性，默认为空。 2、禁止自定义的函数中的this指向window &lt;script&gt; &quot;use strict&quot;; function foo() { console.log(this); } foo(); &lt;/script&gt; 没有 “use strict” 的时候，打印 window对象，有 “use strict” 的时候，打印undefined。 3、严格模式会创建eval作用域eval会解析语句中的字符串。 &lt;script&gt; &quot;use strict&quot;; var name = &#39;Daotin&#39;; eval(&#39;var name = &quot;lvonve&quot;; console.log(name)&#39;); console.log(name); &lt;/script&gt; 如果不加 “use strict”; ，两次打印的结构都为 lvonve；加了的话，打印结果为 lvonve和Daotin。也就相当于给eval创建了一个作用域。 4、对象不能有重名的属性正常模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。 （但是在浏览器console下面并没有显示错误信息。） &lt;script&gt; &quot;use strict&quot;; var o = { p: 1, p: 2 }; // 语法错误 &lt;/script&gt; 5、禁止删除变量严格模式下无法删除变量。只有configurable设置为true的对象属性，才能被删除。 &quot;use strict&quot;; var x; delete x; // 语法错误 var o = Object.create(null, {&#39;x&#39;: { value: 1, configurable: true }}); delete o.x; // 删除成功","categories":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}]},{"title":"CommonJS、AMD、CMD、ES6","slug":"CommonJS、AMD、CMD、ES6","date":"2019-04-08T11:47:28.000Z","updated":"2019-04-09T03:42:55.272Z","comments":true,"path":"2019/04/08/CommonJS、AMD、CMD、ES6/","link":"","permalink":"http://fudaqiang.com/2019/04/08/CommonJS、AMD、CMD、ES6/","excerpt":"","text":"前端模块化：CommonJs、AMD、CMD、ES6 模块化的好处： 模块化的开发可以提升代码的可复用性，方便进行代码的管理。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。目前流行的js模块化规范有CommonJS、AMD、CMD、以及ES6的模块系统。 一、CommonJsnode.js是commonJS规范的主要实践者，它有四个重要的环境变量位为模块化的实现提供支持： module、exports、require、global。实际使用时，用module.exports定义当前模块对外输出的接口(不推荐直接用exports)，用require加载模块。 //定义模块math.js var num = 0; function add(a, b){ return a + b; } module.exports = { //在这里写需要向外暴露的函数、变量 add:add, num } //引用自定义的模块时，参数包含路径，可省略.js var math = require(&#39;./math&#39;) math.add(2,5) //7 //引用node-module包时，不需要带路径 var http = require(&#39;http&#39;) http.createService(()=&gt;{ }).listen(3000) CommonJS用同步的方法加载模块。在服务端，模块文化都存在本地磁盘，读取速度非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。 二、AMD和require.jsAMD规范采用异步方式加载模块，模块的加载不影响它后面的语句运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。这里介绍require.js实现AMD规范的模块化：用require.config()指定引用路径等，用define()定义模块，用require()加载模块。首先我们需要引入require.js文件和一个入口文件main.js中配置require.config()并规定项目中用到等基础模块 /*网页中引入ruire.js及main.js*/ &lt;script src=&quot;require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt; /* main.js 入口文件/主模块*/ require.config({ baseUrl: &quot;js/lib&quot;, //基路径 path:{ &quot;jquery&quot;:&quot;jquery.min&quot;, //实际路径js/lib/jquery.min.js &quot;underscore&quot;:&quot;underscore.min&quot; } }); // 执行基本操作 require([&quot;jquery&quot;,&quot;underscore&quot;],function($,un){ //some code here }) 引用模块的时候，我们将模块名放在[]中作为require()的第一个参数；如果我们定义的模块本身也依赖其他模块，那就需要将他们放在[]中作为define()的第一个参数。 //定义math.js define(function(){ var basicNum = 0; var add = function(x, y){ return x + y; }; return { add: add, basicNum: basicNum }; }); //定义一个依赖underscore.js 模块 defind([&#39;underscore&#39;],function(nu){ var classify = function(list){ nu.conntBy(list,function(num){ return num &gt; 30 ? &#39;old&#39; : &#39;young&#39;; }) }; return{ classify: classify }; }) //引用模块，将模块放在[]内 require([&#39;jquery&#39;,&#39;math&#39;],function($,m){ var sum = math.add(1,2); $(&quot;#box&quot;).html(sum) }); 三、CMD和sea.jsrequire.js在申明依赖的模块时会在第一之间加载并执行模块内的代码： define([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;],function(a,b,c){ //在最前面声明并初始化了要用到的所有模块 if(false){ //即便没用到某个模块，b 但在声明 b 时已经提前执行了 b.foo() } }) CMD是另一种js模块化方案，它于AMD很类似，不同点在于：AMD推崇依赖前置、提前执行，CMD推崇就近、延迟执行。此规范其实是在sea.js推广过程中产出的 //AMD写法 define([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;],function(a,b,c){ //在最前面声明并初始化了要用到的所有模块 if(false){ //即便没用到某个模块，b 但在声明 b 时已经提前执行了 b.foo() } }) //CMD写法 // 定义模块 math.js define(function(require,export,module){ var $ = require(&#39;jquery&#39;); var add = function(a,b){ return a + b; } exports.add = add; }) //加载模块 seajs.use([&#39;math.js&#39;],function(math){ var sum = math.add(1,2) }) AMD与CMD - 真正的不同 还是执行时间// AMD recommended define([&#39;a&#39;, &#39;b&#39;], function(a, b){ a.doSomething(); // 依赖前置，提前执行 b.doSomething(); }) // CMD recommanded define(function(require, exports, module){ var a = require(&quot;a&quot;); a.doSomething(); var b = require(&quot;b&quot;); b.doSomething(); // 依赖就近，延迟执行 }) 四、ES6 ModuleES6在语言标准的层面上，实现了模块功能，而且实现的相当简单，只为成为浏览器和服务器通用的模块定义方案。其模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。 /** 定义模块 math.js **/ var basicNum = 0 var add = function(a,b){ return a + b; }; export {basicNum, add}; // 抛出变量 export var PI = 3.14; export var bar = foo; //抛出 函数 export function foo(){ console.log(&#39;I am not bar.&#39;); } //默认抛出 一个js文件只能有一个默认抛出 export default (a, b)=&gt;{ return a + b } /** 引用模块 **/ import{basicNum, add } from &#39;./math&#39;; function test(el){ el.innerHTML = add(1,basicNum); } import { foo as bar } from &quot;./math&quot;; //as 设置别名 bar(); import * as math from &quot;./math&quot;; //*所有抛出 都配置到 math身上 math.PI math.foo() 如上例所示，使用import命令的时候，用户需要知道所要加载的变量名或函数名。其实ES6还提供了export default 命令，为模块指定默认输出，对应的import语句不需要使用大括号。这也更趋近于ADM的引用写法。 五、 ES6 模块与 CommonJS 模块的差异1. CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值的引用。 CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。 ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 2. CommonJS模块是运行时加载，ES6模块是在编译时输出接口 运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。 编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码， import 时采用静态命令的形式。即在 import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。","categories":[{"name":"技术 模块化","slug":"技术-模块化","permalink":"http://fudaqiang.com/categories/技术-模块化/"}],"tags":[],"keywords":[{"name":"技术 模块化","slug":"技术-模块化","permalink":"http://fudaqiang.com/categories/技术-模块化/"}]},{"title":"测试Mathjax支持","slug":"测试Mathjax支持","date":"2019-02-21T09:55:11.000Z","updated":"2019-04-09T03:45:11.289Z","comments":true,"path":"2019/02/21/测试Mathjax支持/","link":"","permalink":"http://fudaqiang.com/2019/02/21/测试Mathjax支持/","excerpt":"","text":"1When $a \\ne 0$, there are two solutions to (ax^2 + bx + c = 0) and they are$$x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.$$ 2","categories":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}]},{"title":"Hexo-Theme-Sakura","slug":"Hexo-Theme-Sakura","date":"2018-12-12T14:16:01.000Z","updated":"2019-04-08T08:18:18.484Z","comments":true,"path":"2018/12/12/Hexo-Theme-Sakura/","link":"","permalink":"http://fudaqiang.com/2018/12/12/Hexo-Theme-Sakura/","excerpt":"","text":"最近又一次接触到了web端全景，是在720yun上，发现有好多用户上传的全景照片。再也按捺不住那颗好奇的心，去探究了下720云是怎么实现web端全景展示的。 分析加载的资源我们使用f12开发者工具，查看分析找到了krp-player这个关键的js文件，并在js文件首部找到了它的原名”krpano”（稍微提一下：可能你还听说有其他插件或方式实现web全景:比如three.js，但那些都不是很成熟，存在大大小小的bug，而krpano比较成熟也是大部分全景网站所使用的，所以是收费的。）。于是搜索到了它的官网，并进行下载它的安装包（下载速度太慢可以搜索其百度网盘资源去下载） 安装krpano安装krpano安装krpano安装krpano下载好后，双击安装到目录（自定义）。安装好后如下图 使用krpano使用krpano使用krpano使用krpano使用教程可以参考krpano360的。准备一张或多张全景图：注意：要求的全景图长宽比为2:1直接将全景拖到需要生成类型的bat上（我这里是MAKE VTOUR (VR-OPT) droplet，也是教程所推荐的）然后krpano就好自动处理图片，并生成html网页文件。生成的文件和图片在同一目录，如我的图片在桌面，生成的文件也在桌面。这样子直接打开html文件还不能浏览全景图片，需要在服务器环境下访问才行（其他服务器环境也行）这里我们用krpano自带的server工具。双击它：可以看到服务开启的目录在krpano的安装目录下，我们可以把生成的文件复制过来访问：（这里我在安装目录下新建了一个文件夹）再打开之前server工具给的那个地址，进入到目录下，点击tour.html即可预览全景预览如下：发现它的水印是不是多的恐怖2333333，需要购买才能去除。或者…… 最后其实可以退一步，就用一些全景平台就行了，比如720yun。这篇文章仅是为了探究下全景实现，到此为止了大致了解了，完。","categories":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"http://fudaqiang.com/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"http://fudaqiang.com/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}]},{"title":"修饰符","slug":"修饰符","date":"2018-10-08T14:16:33.000Z","updated":"2019-04-09T03:45:36.807Z","comments":true,"path":"2018/10/08/修饰符/","link":"","permalink":"http://fudaqiang.com/2018/10/08/修饰符/","excerpt":"","text":"一、事件修饰符 .stop ： 阻止冒泡 .prevent ： 阻止默认事件（比如点击超链接，阻止跳转到默认网页） .capture ： 添加事件侦听器时使用事件捕获模式（与冒泡模式相反） .self ：只当事件在该元素本身（比如不是子元素）触发时触发回调 .once ：事件只触发一次，之后还原标签本身的行为。 示例： &lt;div id=&quot;app&quot;&gt; &lt;!-- 使用 .stop 阻止冒泡 --&gt; &lt;div class=&quot;inner&quot; @click=&quot;div1Handler&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;戳他&quot; @click.stop=&quot;btnHandler&quot;&gt; &lt;/div&gt; &lt;!-- 使用 .prevent 阻止默认行为（跳转到百度首页） --&gt; &lt;a href=&quot;http://www.baidu.com&quot; @click.prevent=&quot;linkClick&quot;&gt;有问题，先去百度&lt;/a&gt; &lt;!-- 使用 .capture 实现捕获触发事件的机制：跟冒泡相反，从外到里--&gt; &lt;div class=&quot;inner&quot; @click.capture=&quot;div1Handler&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;戳他&quot; @click=&quot;btnHandler&quot;&gt; &lt;/div&gt; &lt;!-- 使用 .self 实现只有点击当前元素时候，才会触发事件处理函数 --&gt; &lt;div class=&quot;inner&quot; @click.self=&quot;div1Handler&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;戳他&quot; @click=&quot;btnHandler&quot;&gt; &lt;/div&gt; &lt;!-- 使用 .once 只触发一次事件处理函数（如下案例只触发一次点击事件，之后还原标签本身的行为） --&gt; &lt;a href=&quot;http://www.baidu.com&quot; @click.prevent.once=&quot;linkClick&quot;&gt;有问题，先去百度&lt;/a&gt; &lt;/div&gt; .stop 和 .self 的区别： &lt;!-- stop 会阻止冒泡行为 --&gt; &lt;div class=&quot;outer&quot; @click=&quot;div2Handler&quot;&gt; &lt;div class=&quot;inner&quot; @click=&quot;div1Handler&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;戳他&quot; @click.stop=&quot;btnHandler&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- .self 只会阻止自己身上冒泡行为的触发，并不会真正阻止冒泡的行为 --&gt; &lt;div class=&quot;outer&quot; @click=&quot;div2Handler&quot;&gt; &lt;div class=&quot;inner&quot; @click.self=&quot;div1Handler&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;戳他&quot; @click=&quot;btnHandler&quot;&gt; &lt;/div&gt; &lt;/div&gt; 二、按键修饰符我们现在有个需求就是输入ID和name后不点击add按钮，而是按下回车键也需要添加到列表中。 我们可以在name输入框中加入按键抬起事件，并且指定是enter键抬起时才触发。 &lt;label for=&quot;name&quot;&gt; name: &lt;input type=&quot;text&quot; id=&quot;name&quot; v-model=&quot;name&quot; @keyup.enter=&quot;addClick&quot;&gt; .enter ： 就是按键修饰符。 系统提供的按键修饰符有： .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 如果我们想自定义其他的按键怎么办呢？ 通过Vue.config.keyCodes.f2 = 113; ；可以将f2作为按键修饰符添加到系统按键修饰符中。 具体每个按键的值是多少？下面是常见的按键的码。 keyCode 8 = BackSpace BackSpace keyCode 9 = Tab Tab keyCode 12 = Clear keyCode 13 = Enter keyCode 16 = Shift_L keyCode 17 = Control_L keyCode 18 = Alt_L keyCode 19 = Pause keyCode 20 = Caps_Lock keyCode 27 = Escape Escape keyCode 32 = space keyCode 33 = Prior keyCode 34 = Next keyCode 35 = End keyCode 36 = Home keyCode 37 = Left keyCode 38 = Up keyCode 39 = Right keyCode 40 = Down keyCode 41 = Select keyCode 42 = Print keyCode 43 = Execute keyCode 45 = Insert keyCode 46 = Delete keyCode 47 = Help keyCode 48 = 0 equal braceright keyCode 49 = 1 exclam onesuperior keyCode 50 = 2 quotedbl twosuperior keyCode 51 = 3 section threesuperior keyCode 52 = 4 dollar keyCode 53 = 5 percent keyCode 54 = 6 ampersand keyCode 55 = 7 slash braceleft keyCode 56 = 8 parenleft bracketleft keyCode 57 = 9 parenright bracketright keyCode 65 = a A keyCode 66 = b B keyCode 67 = c C keyCode 68 = d D keyCode 69 = e E EuroSign keyCode 70 = f F keyCode 71 = g G keyCode 72 = h H keyCode 73 = i I keyCode 74 = j J keyCode 75 = k K keyCode 76 = l L keyCode 77 = m M mu keyCode 78 = n N keyCode 79 = o O keyCode 80 = p P keyCode 81 = q Q at keyCode 82 = r R keyCode 83 = s S keyCode 84 = t T keyCode 85 = u U keyCode 86 = v V keyCode 87 = w W keyCode 88 = x X keyCode 89 = y Y keyCode 90 = z Z keyCode 96 = KP_0 KP_0 keyCode 97 = KP_1 KP_1 keyCode 98 = KP_2 KP_2 keyCode 99 = KP_3 KP_3 keyCode 100 = KP_4 KP_4 keyCode 101 = KP_5 KP_5 keyCode 102 = KP_6 KP_6 keyCode 103 = KP_7 KP_7 keyCode 104 = KP_8 KP_8 keyCode 105 = KP_9 KP_9 keyCode 106 = KP_Multiply KP_Multiply keyCode 107 = KP_Add KP_Add keyCode 108 = KP_Separator KP_Separator keyCode 109 = KP_Subtract KP_Subtract keyCode 110 = KP_Decimal KP_Decimal keyCode 111 = KP_Divide KP_Divide keyCode 112 = F1 keyCode 113 = F2 keyCode 114 = F3 keyCode 115 = F4 keyCode 116 = F5 keyCode 117 = F6 keyCode 118 = F7 keyCode 119 = F8 keyCode 120 = F9 keyCode 121 = F10 keyCode 122 = F11 keyCode 123 = F12 keyCode 124 = F13 keyCode 125 = F14 keyCode 126 = F15 keyCode 127 = F16 keyCode 128 = F17 keyCode 129 = F18 keyCode 130 = F19 keyCode 131 = F20 keyCode 132 = F21 keyCode 133 = F22 keyCode 134 = F23 keyCode 135 = F24 示例： &lt;input type=&quot;text&quot; id=&quot;name&quot; v-model=&quot;name&quot; @keyup.f2=&quot;addClick&quot;&gt; //... &lt;script&gt; Vue.config.keyCodes.f2 = 113; &lt;/script&gt;","categories":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}]},{"title":"javascript数组去重","slug":"javascript数组去重","date":"2018-10-08T12:03:06.000Z","updated":"2019-04-08T14:22:22.442Z","comments":true,"path":"2018/10/08/javascript数组去重/","link":"","permalink":"http://fudaqiang.com/2018/10/08/javascript数组去重/","excerpt":"","text":"set去重var arr = [5,3,1,2,&quot;c&quot;,&quot;a&quot;,3,4,5,&quot;c&quot;,1,&quot;b&quot;,2,&quot;a&quot;,3,2,1,4,5] var newSet = new Set(arr) console.log([...newSet]) Array.prototype.includes() var newArr = [] for (var i of arr) { if (!newArr.includes(i)) { newArr.push(i) } } console.log(newArr) 相邻元素去重var arr = [5,3,1,2,3,4,5,1,2,3,2,1,4,5] var ar = arr.sort((a, b) =&gt; { return a - b; }) for (var i = 0; i &lt; ar.length; i++) { for (var j = 0; j &lt; ar.length; j++) { if (ar[i] == ar[j + 1]) { ar.splice(i, 1) } } } console.log(ar) Array.prototype.reduce() var arr = [5,3,1,2,&quot;c&quot;,&quot;a&quot;,3,4,5,&quot;c&quot;,1,&quot;b&quot;,2,&quot;a&quot;,3,2,1,4,5] init = [] var result = arr.sort().reduce((init, current) =&gt; { console.log(init, current) if (init.length === 0 || init[init.length - 1] !== current) { init.push(current); } return init; }, []); console.log(result) 对象去重var arr = [5,3,1,2,&quot;c&quot;,&quot;a&quot;,3,4,5,&quot;c&quot;,1,&quot;b&quot;,2,&quot;a&quot;,3,2,1,4,5] var obj = {} for (var i of arr) { console.log(i) obj[i] = i } var brr = Object.values(obj) console.log(brr) filter 去重var arr = [5,3,1,2,&quot;c&quot;,&quot;a&quot;,3,4,5,&quot;c&quot;,1,&quot;b&quot;,2,&quot;a&quot;,3,2,1,4,5] function unique(arr) { return arr.filter((item, index, brr) =&gt; { return brr.indexOf(item) === index }) } console.log(unique(arr))","categories":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}]}]}