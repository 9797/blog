{"meta":{"title":"強い","subtitle":null,"description":"付大强,关于付大强,付大强个人简历,web付大强,前端付大强,大强,小强,小强精神,付大强的个人博客,前端小强,付大强的个人首页,付大强的个人中心,付大强的个人主页,打不死的小强,fudaqiang,FUDAQIANG,FDQ,小强强,强强,小鬼,淙淙","author":"強い","url":"http://fudaqiang.com"},"pages":[{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2019-04-08T07:10:27.253Z","comments":false,"path":"bangumi/index.html","permalink":"http://fudaqiang.com/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2019-04-08T07:10:27.253Z","comments":false,"path":"about/index.html","permalink":"http://fudaqiang.com/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... function bot_ui_ini() { var botui = new BotUI(\"hello-mashiro\"); botui.message.add({ delay: 800, content: \"Hi, there111👋\" }).then(function () { botui.message.add({ delay: 1100, content: \"这里是 Mashiro\" }).then(function () { botui.message.add({ delay: 1100, content: \"一个可爱的蓝孩子~\" }).then(function () { botui.action.button({ delay: 1600, action: [{ text: \"然后呢？ 😃\", value: \"sure\" }, { text: \"少废话！ 🙄\", value: \"skip\" }] }).then(function (a) { \"sure\" == a.value && sure(); \"skip\" == a.value && end() }) }) }) }); var sure = function () { botui.message.add({ delay: 600, content: \"😘\" }).then(function () { secondpart() }) }, end = function () { botui.message.add({ delay: 600, content: \"![...](https://view.moezx.cc/images/2018/05/06/a1c4cd0452528b572af37952489372b6.md.jpg)\" }) }, secondpart = function () { botui.message.add({ delay: 1500, content: \"目前就读于上海财经大学\" }).then(function () { botui.message.add({ delay: 1500, content: \"向往技术却误入商科，但后来喜欢上了经济学…\" }).then(function () { botui.message.add({ delay: 1200, content: \"因为数据分析也需要Coder嘛\" }).then(function () { botui.message.add({ delay: 1500, content: \"主攻 R 语言和 Python，略懂 STATA，偶尔也折腾 HTML/CSS/JavaScript/PHP\" }).then(function () { botui.message.add({ delay: 1500, content: \"研究的方向，是经济/金融方向的数据分析（data science）以及机器学习（machine learning）\" }).then(function () { botui.message.add({ delay: 1800, content: \"喜欢画画，希望有一天能够被称为画师\" }).then(function () { botui.action.button({ delay: 1100, action: [{ text: \"为什么叫Mashiro呢？ 🤔\", value: \"why-mashiro\" }] }).then(function (a) { thirdpart() }) }) }) }) }) }) }) }, thirdpart = function () { botui.message.add({ delay: 1E3, content: \"Mashiro以及站名都来自一部动画，因为和主角有一样的爱好~ 如果有兴趣可以找找首页上的视频~\" }).then(function () { botui.action.button({ delay: 1500, action: [{ text: \"为什么是白猫呢？ 🤔\", value: \"why-cat\" }] }).then(function (a) { fourthpart() }) }) }, fourthpart = function () { botui.message.add({ delay: 1E3, content: \"因为对GitHub有种执念… \" }).then(function () { botui.message.add({ delay: 1100, content: \"而且我真的是猫控！\" }).then(function () { botui.action.button({ delay: 1500, action: [{ text: \"域名有什么含意吗？(ง •_•)ง\", value: \"why-domain\" }] }).then(function (a) { fifthpart() }) }) }) }, fifthpart = function () { botui.message.add({ delay: 1E3, content: \"emmmm，看备案信息你就知道了=.= 本来想要zheng.xin的，但50万真买不起。。\" }).then(function () { botui.message.add({ delay: 1600, content: \"那么，仔细看看我的博客吧？ ^_^\" }) }) } } bot_ui_ini()","keywords":"关于"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-04-08T07:10:27.254Z","comments":false,"path":"client/index.html","permalink":"http://fudaqiang.com/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-04-08T07:10:27.254Z","comments":true,"path":"comment/index.html","permalink":"http://fudaqiang.com/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-04-08T07:10:27.255Z","comments":false,"path":"donate/index.html","permalink":"http://fudaqiang.com/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-04-08T07:10:27.255Z","comments":false,"path":"lab/index.html","permalink":"http://fudaqiang.com/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-04-08T07:10:27.256Z","comments":true,"path":"tags/index.html","permalink":"http://fudaqiang.com/tags/index.html","excerpt":"","text":""},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-04-08T07:10:27.256Z","comments":true,"path":"rss/index.html","permalink":"http://fudaqiang.com/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-04-08T07:10:27.257Z","comments":false,"path":"theme-sakura/index.html","permalink":"http://fudaqiang.com/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-04-08T11:35:47.553Z","comments":false,"path":"music/index.html","permalink":"http://fudaqiang.com/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2019-04-08T11:09:45.826Z","comments":true,"path":"links/index.html","permalink":"http://fudaqiang.com/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-04-08T07:10:27.257Z","comments":false,"path":"video/index.html","permalink":"http://fudaqiang.com/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"防抖debounce","slug":"防抖debounce","date":"2019-02-09T06:02:06.000Z","updated":"2019-04-09T06:34:14.955Z","comments":true,"path":"2019/02/09/防抖debounce/","link":"","permalink":"http://fudaqiang.com/2019/02/09/防抖debounce/","excerpt":"","text":"function debounce(fn, wait) { var timer = null; return function () { if (timer !== null){ clearTimeout(timer); timer = null; } timer = setTimeout(fn, wait); } }","categories":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}]},{"title":"节流throttle","slug":"节流throttle","date":"2019-02-09T06:01:31.000Z","updated":"2019-04-09T06:34:13.259Z","comments":true,"path":"2019/02/09/节流throttle/","link":"","permalink":"http://fudaqiang.com/2019/02/09/节流throttle/","excerpt":"","text":"function throttle(fn, wait) { let timer = null; return function () { if (timer) return timer = setTimeout(() =&gt; { fn() timer = null }, wait) }; }; function fn() { console.log(11) } setInterval(throttle(fn, 1000), 100);","categories":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}]},{"title":"vue组件","slug":"vue组件","date":"2018-12-03T05:40:49.000Z","updated":"2019-04-09T05:48:33.086Z","comments":true,"path":"2018/12/03/vue组件/","link":"","permalink":"http://fudaqiang.com/2018/12/03/vue组件/","excerpt":"","text":"一、Vue组件什么是组件： 组件的出现，就是为了拆分 Vue 实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可； 组件化和模块化的不同： 模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一； 组件化： 是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用； 二、定义组件1、定义全局组件通过 Vue.component(cname,option)函数来定义 其中cname为字符串类型 代表组件名；option用于配置组件相关属性。 相关属性：例如:data computed methods template watch等等。 // main.js import Vue from &#39;vue&#39; // 全局组件 // 全局组件的定义一定要在new Vue之前。 // 定义之后到处可以使用，并且不需再声明 Vue.component(&#39;mydiv&#39;, { //不能在顶层元素使用v-for，因为顶层元素只能有一个 template: ` &lt;div&gt; &lt;div v-for=&quot;item in goods&quot;&gt;{{item.name}}&lt;/div&gt; &lt;/div&gt; `, data: function() { return { goods: [ { name: &#39;Daotin&#39;, age: 18 }, { name: &#39;lvonve&#39;, age: 19 }, { name: &#39;wenran&#39;, age: 20 } ] } } }); new Vue({ el: &#39;#app&#39;, data:{} }); 全局组件的使用： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;!--全局组件的使用--&gt; &lt;my-login&gt;&lt;/my-login&gt; &lt;/body&gt; &lt;/html&gt; 注意： 0、不论是全局组件还是局部组件，组件的 template 属性指向的模板内容，必须有且只能有唯一的一个顶层元素，否则会报错。 1、使用组件的时候，双标签和单标签的方式都可以。&lt;my-login&gt;&lt;/my-login&gt; 或者 &lt;my-login /&gt; 2、组件的内部除了有 template，还有data，methods，watch，computed等所有vue实例的属性。 3、使用 Vue.component 定义全局组件的时候，组件名称使用了 驼峰命名（如myLogin），则在调用组件的时候，需要把大写的驼峰改为小写的字母，同时在两个单词之前，使用 - 链接（&lt;my-login&gt;&lt;/my-login&gt;）；如果不使用驼峰,则直接拿名称来使用即可； 4、全局组件定义之后可以可以直接使用，不需要import引入 5、定义组件的时候，data为一个匿名函数，其返回值为一个对象。在这个返回对象里面填写需要的数据。 6、定义全局组件的时候，必须在vue初始化之前完成，也就是必须放在new Vue()代码之前。 2、定义局部组件通过components : { componentname:option} 的形式注册过一个子组件后才能在当前组件内使用该组件。 定义局部组件，就是再vue实例中定义组件。 // main.js import Vue from &#39;vue&#39; // 子组件定义的时候，如果提出组件的配置（比如c），那么也要放在new Vue之前。 let c = { template: ` &lt;div&gt; &lt;div v-for=&quot;item in names&quot;&gt;{{item.name}}&lt;/div&gt; &lt;/div&gt; `, data: function() { return { names: [ { name: &#39;good1&#39; }, { name: &#39;good2&#39; }, { name: &#39;good3&#39; } ] } } }; new Vue({ el: &#39;#app&#39;, data: { username: &#39;daotin&#39; }, // 定义局部组件 components: { goods:c } }); 子组件的使用： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;!--局部组件的使用--&gt; &lt;goods&gt;&lt;/goods&gt; &lt;/body&gt; &lt;/html&gt; 注意： 1、局部组件要使用的话，在哪个组件使用，就要在哪个组件中定义，也叫注册。 2、定义子组件的时候，如果把option提出来写，也必须放在new Vue 之前。 三、动态组件定义三个子组件Home.js, Goods.js, Users.js 一般组件的文件名首字母大写。 然后创建一个主组件App.js。在main.js里面这样做： 在main.js里面定义局部组件App，然后在main.js里面也可以定义template模板。 在main.js里面定义的模板会覆盖掉index.html里面的&lt;div id=&quot;app&quot;&gt;&lt;/div&gt; 这里main.js里面的模板就是子组件App的内容，实际上这样写的目的就是在主页显示App的内容，所有其他组件比如Home.js等在App.js引入进行显示。 new Vue({ el: &#39;#app&#39;, data: {}, template: &#39;&lt;App/&gt;&#39;, components: { App } }); 看看各个文件的内容： // Home.js export let Home = { template: ` &lt;div&gt; &lt;h2&gt;首页&lt;/h2&gt; &lt;/div&gt; ` } // Goods.js export let Goods = { template: ` &lt;div&gt; &lt;ul&gt; &lt;li v-for=&quot;good in goods&quot;&gt;{{good.goodsName}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; `, data() { return { goods: [ { goodsName: &#39;苹果&#39; }, { goodsName: &#39;香蕉&#39; }, { goodsName: &#39;梨&#39; }, ] } }, } //Users.js export let Users = { template: ` &lt;div&gt; &lt;ul&gt; &lt;li v-for=&quot;user in users&quot;&gt;{{user.name}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; `, data() { return { users: [ { name: &#39;lvonve&#39; }, { name: &#39;daotin&#39; }, { name: &#39;wenran&#39; }, ] } }, } 主组件App.js： // 主组件 import { Home } from &#39;./pages/Home&#39; import { Goods } from &#39;./pages/Goods&#39; import { Users } from &#39;./pages/Users&#39; export let App = { template: ` &lt;div&gt; &lt;a href=&quot;javascript:;&quot; @click=&quot;goPage(nav.name)&quot; v-for=&quot;nav in navs&quot;&gt;{{nav.text}}&lt;/a&gt; &lt;Component :is=&quot;currentPage&quot; /&gt; &lt;/div&gt; `, data() { return { currentPage: &#39;Goods&#39;, navs: [ { text: &#39;首页&#39;, name: &#39;Home&#39; }, { text: &#39;商品列表&#39;, name: &#39;Goods&#39; }, { text: &#39;用户列表&#39;, name: &#39;Users&#39; } ] } }, methods: { goPage(pagename) { this.currentPage = pagename; } }, components: { Home, Goods, Users } } 在主组件先import引入其他组件，然后使用局部组件的方式进行定义，之后使用&lt;Component is=&quot;Home&quot; /&gt; 类似于&lt;Home /&gt; ，由于这里需要动态显示，所以is可变，就成了&lt;Component :is=&quot;currentPage&quot; /&gt; 这样点击不同的a标签就会显示不同的内容（默认显示Goods组件内容）。 四、组件间传值1、父组件向子组件传值有这样一个需求，我们的Home，Goods，Users组件都需要有一个相同的头部组件Header，但是需要Header里面的内容不同，这就需要父组件Home，Goods，Users传给子组件Header不同的值来显示不同的内容。 定义一个Header组件。 // Header.js export let Header = { template: ` &lt;div&gt; &lt;h3&gt; 我是Header组件 &lt;/h3&gt; &lt;/div&gt; ` } 父组件怎么给子组件传值呢？ 使用props。 父组件传递的方式：在子组件中自定义一个属性，名称随意，这里叫title，属性值为Home， template: ` &lt;div&gt; &lt;Header title=&quot;Home&quot;/&gt; &lt;h2&gt;首页&lt;/h2&gt; &lt;/div&gt; `, 然后在子组件里面接收父组件传来的数据：使用props接收来自父组件的数据，接收属性为一个数组，里面的值就是传过来的属性名。 既然是数组，就可以接收多个父组件传过来的数据。 export let Header = { // 使用props接收来自父组件的数据，接收属性为一个数组，里面的值就是传过来的属性名 props: [&#39;title&#39;], template: ` &lt;div&gt; &lt;h3&gt;我是Header组件&lt;/h3&gt; &lt;p&gt;我来自{{title}}&lt;/p&gt; &lt;/div&gt; ` } 1.1、props类型验证我们上面props传递的都是字符串，如果不小心传递的是数组啊，对象啊什么的，显示的时候也只会以字符串的显示显示，如何对props传递的数据进行类型声明呢？ 我们需要在子组件里面进行props声明： export let Header = { props: { obj: Object, title: String }, template: ` &lt;div&gt; &lt;h3&gt;我是Header组件&lt;/h3&gt; &lt;p&gt;我来自{{title}}&lt;/p&gt; &lt;p&gt;{{obj}}&lt;/p&gt; &lt;/div&gt; ` } 父组件传值的时候和之前一样： import { Header } from &#39;../components/Header&#39; export let Home = { data() { return { title: &#39;Home&#39;, obj: { username: &#39;Daotin&#39; } } }, template: ` &lt;div&gt; &lt;Header :title=&quot;title&quot; :obj=&quot;obj&quot;/&gt; &lt;h2&gt;首页&lt;/h2&gt; &lt;/div&gt; `, components: { Header } } 1.2、props必填验证还有个问题是当父组件不填写title值的时候，子组件不显示，但是不会报错。 如何设置子组件声明的值为必填属性呢？ 子组件这样设置： export let Header = { props: { obj: Object, title: { type: String, required: true } }, template: ` &lt;div&gt; &lt;h3&gt;我是Header组件&lt;/h3&gt; &lt;p&gt;我来自{{title}}&lt;/p&gt; &lt;p&gt;{{obj}}&lt;/p&gt; &lt;/div&gt; ` } 父组件如果不写title属性的话，会报以下错误： 1.3、props默认值子组件： export let Header = { props: { obj: Object, title: { type: String, default: &#39;Home&#39; // required: true } }, template: ` &lt;div&gt; &lt;h3&gt;我是Header组件&lt;/h3&gt; &lt;p&gt;我来自{{title}}&lt;/p&gt; &lt;p&gt;{{obj}}&lt;/p&gt; &lt;/div&gt; ` } 当子组件设置默认属性的时候，就不需要必填属性了，因为有了默认值肯定填写了。 1.4、props自定义匹配规则如果父组件传递的是个数组，我们想限制数组的长度怎么办？上面的属性都不可以限制，这时候就需要自定义匹配规则了。 这里我们限制传递过来的数组长度在3-10之间长度。 子组件： export let Header = { props: { obj: Object, title: { type: String, default: &#39;Default Home&#39; // required: true }, arr: { type: Array, required: true, validator: function(value) { // value就是父组件传递过来的数组 if (value.length &gt;= 3 &amp;&amp; value.length &lt;= 10) { // 满足条件返回true return true; } else { // 不满足条件返回false return false; } } } }, template: ` &lt;div&gt; &lt;h3&gt;我是Header组件&lt;/h3&gt; &lt;p&gt;我来自{{title}}&lt;/p&gt; &lt;p&gt;{{obj}}&lt;/p&gt; &lt;/div&gt; ` } 父组件这时传递个空数组： import { Header } from &#39;../components/Header&#39; export let Home = { data() { return { title: &#39;Home&#39;, obj: { username: &#39;Daotin&#39; }, arr: [] } }, template: ` &lt;div&gt; &lt;Header :title=&quot;title&quot; :obj=&quot;obj&quot; :arr=&quot;arr&quot;/&gt; &lt;h2&gt;首页&lt;/h2&gt; &lt;/div&gt; `, components: { Header } } 会报错如下，当我们传递的数组的长度满足的时候就不会报错了。 但是我觉得这个提示不明显，我们可以手动报错。 export let Header = { props: { obj: Object, title: { type: String, default: &#39;Default Home&#39; // required: true }, arr: { type: Array, required: true, validator: function(value) { // value就是父组件传递过来的数组 if (value.length &gt;= 3 &amp;&amp; value.length &lt;= 10) { return true; } else { // return false; throw new Error(&#39;数组的长度必须在3-10之间&#39;); } } } }, template: ` &lt;div&gt; &lt;h3&gt;我是Header组件&lt;/h3&gt; &lt;p&gt;我来自{{title}}&lt;/p&gt; &lt;p&gt;{{obj}}&lt;/p&gt; &lt;/div&gt; ` } 现在报错的信息就很明显了。 2、子组件向父组件传值在此之前先介绍个插件string-loader ，这个插件可以让我们组件的template属性的值提出到单独的html页面，便于书写。 安装插件 npm i string-loader -D 配置config文件 module: { rules: [ { test: /\\.html$/, loader: &#39;string-loader&#39; } ] }, 这里创建一个子组件A.js和A组件的template文件A.html。 A组件如何使用外部的template呢？ &lt;!--A.html--&gt; &lt;div&gt; &lt;h4&gt; 我说A组件。 &lt;span&gt;count = {{count}}&lt;/span&gt; &lt;button @click=&quot;add&quot;&gt;+&lt;/button&gt; &lt;/h4&gt; &lt;/div&gt; 首先要导入A.html文件才能使用，导入的方式和js一样。 // A.js import htmlA from &#39;./A.html&#39; export let A = { template: htmlA } 然后用相同的方式创建B.js和B.html文件。然后在父组件Home.js引入使用A组件和B组件。 现在的代码结构如下： // A.js import htmlA from &#39;./A.html&#39; export let A = { props: [&#39;title&#39;], template: htmlA, data() { return { count: 0 } }, methods: { add() { this.count++; } } } // B.js import htmlB from &#39;./B.html&#39; export let B = { props: [&#39;cCount&#39;], template: htmlB } // Home.js import { Header } from &#39;../components/Header&#39; import { A } from &#39;../components/A&#39; import { B } from &#39;../components/B&#39; export let Home = { template: ` &lt;div&gt; &lt;Header :title=&quot;title&quot;&gt;&lt;/Header&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;A&gt;&lt;/A&gt; &lt;B&gt;&lt;/B&gt; &lt;/div&gt; `, data() { return { title: &#39;首页的title&#39;, count: 0 } }, components: { Header, A, B } } A.html和B.html &lt;!-- A.html --&gt; &lt;div&gt; &lt;h4&gt; 我是A组件。 &lt;span&gt;count = {{count}}&lt;/span&gt; &lt;button @click=&quot;add&quot;&gt;+&lt;/button&gt; &lt;/h4&gt; &lt;/div&gt; &lt;!-- B.html --&gt; &lt;div&gt; &lt;h4&gt; 我是B组件。 &lt;span&gt;count = {{cCount}}&lt;/span&gt; &lt;/h4&gt; &lt;/div&gt; 此时的需求是点击A组件的按钮，A组件的count++，然后将count值传给Home父组件。 子组件传值给父组件使用：子组件.$emit(事件名，发送给父组件的数据) // A.js import htmlA from &#39;./A.html&#39; export let A = { props: [&#39;title&#39;], template: htmlA, data() { return { count: 0 } }, methods: { add() { this.count++; } }, // 监听数据的变化 watch: { count() { this.$emit(&#39;countChange&#39;, this.count); } } } 我们在watch里面监听count值的变化，然后将count值使用this.$emit(&#39;countChange&#39;, this.count);发送给父组件，一旦count值发生变化，就会触发countChange事件，然后将this.count发送给父组件。 这时候在父组件监听这个countChange事件，拿到子组件传过来的count： import { Header } from &#39;../components/Header&#39; import { A } from &#39;../components/A&#39; import { B } from &#39;../components/B&#39; export let Home = { template: ` &lt;div&gt; &lt;Header :title=&quot;title&quot;&gt;&lt;/Header&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;A @countChange=&quot;change&quot;&gt;&lt;/A&gt; &lt;B&gt;&lt;/B&gt; &lt;/div&gt; `, data() { return { title: &#39;首页的title&#39;, count: 0 } }, methods: { change(count) { console.log(count); // 打印得到的子组件count值 this.count = count; } }, components: { Header, A, B } } 如果想要change事件传多个值，比如还想传个一个参数为123，在第一个参数的位置，那么模板的写法就要修改： &lt;A @countChange=&quot;change(123, $event)&quot;&gt;&lt;/A&gt; ，第二个参数$event 就相当于子组件传来的数据。 其实之前不写参数的时候，就类似与&lt;A @countChange=&quot;change($event)&quot;&gt;&lt;/A&gt;这种写法。 3、子组件之间相互传值方式一：中间人模式 通过父组件间接传值（通过props的方式传值。） 子组件A –&gt; 父组件 –&gt; 子组件B， 方式二：中央事件总线 创建新的vue实例做中间人传话，分别调用emit()进行触发和on()进行监听。 创建一个toolVue.js文件： import Vue from &#39;vue&#39; export let media = new Vue(); toolVue文件只负责创建一个vue实例，然后导出组件。 A，B组件引入toolVue组件。然后A的count变化的时候触发countChange函数，在B里面调用countChange函数得到A传递的数据。 // A.js import { media } from &#39;../toolVue&#39; import htmlA from &#39;./A.html&#39; export let A = { props: [&#39;title&#39;], template: htmlA, data() { return { count: 0 } }, methods: { add() { this.count++; } }, watch: { count() { // 通过media组件，当count变化时触发countChange，并传入count值 media.$emit(&#39;countChange&#39;, this.count); } }, components: { media } } // B.js import { media } from &#39;../toolVue&#39; import htmlB from &#39;./B.html&#39; export let B = { // props: [&#39;cCount&#39;], template: htmlB, data() { return { cCount: 0 } }, components: { media }, mounted() { // 通过media，调用countChange函数，得到A的count值 // 注意这里面的this是media并不是B，所以要用箭头函数 media.$on(&#39;countChange&#39;, count =&gt; { this.cCount = count; }) }, } 完成子组件A的count传递到子组件B。 // 注意这里面的this是media并不是B，所以要用箭头函数media.$on(‘countChange’, count =&gt; {​ this.cCount = count;}) 3.1、Tips需要注意的是：如果是同一个页面的两个组件传递数据的时候，可能会发生接收的组件先监听事件，而后发送组件才发送数据，这样接收组件就接收不到数据了。 解决办法：给发送组件加个延时。 // 发送组件 setTimeout(() =&gt; { media.$emit(&#39;hasUser&#39;, this.user); }, 50); // 接收组件 media.$on(&#39;hasUser&#39;, user =&gt; { this.user = user; }); (———下面是旧笔记———) 三、组件切换我们在登录注册一个网站的时候，经常看到两个按钮，一个登录，一个注册，如果你没有账号的话，需要先注册才能登录。我们在点击登录和注册的时候，网页会相应的切换，登录页面就是登陆组件，注册页面就是注册组件，那么点击登录和注册，如何实现组件的切换呢？ 1、方式一使用flag标识符结合v-if和v-else切换组件 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;!-- 给a注册点击事件，切换flag状态 --&gt; &lt;a href=&quot;javascript:;&quot; @click.prevent=&quot;flag=true&quot;&gt;登录&lt;/a&gt; &lt;a href=&quot;javascript:;&quot; @click.prevent=&quot;flag=false&quot;&gt;注册&lt;/a&gt; &lt;!-- 使用v-if v-else切换组件 --&gt; &lt;login v-if=&quot;flag&quot;&gt; &lt;/login&gt; &lt;register v-else=&quot;flag&quot;&gt; &lt;/register&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&#39;login&#39;, { template: &#39;&lt;h3&gt;登录组件&lt;/h3&gt;&#39; }); Vue.component(&#39;register&#39;, { template: &#39;&lt;h3&gt;注册组件&lt;/h3&gt;&#39; }); var vm = new Vue({ el: &quot;#box&quot;, data: { flag: true }, methods: {} }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 缺陷：由于flag的值只有true和false，所以只能用于两个组件间 的切换，当大于两个组件的切换就不行了。 2、方式二使用 component元素的:is属性来切换不同的子组件 使用 &lt;component :is=&quot;componentId&quot;&gt;&lt;/component&gt; 来指定要切换的组件。 componentId：为需要显示的组件名称，为一个字符串，可以使用变量指定。 componentId: &#39;login&#39; // 默认显示登录组件。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;!-- 给a注册点击事件，切换flag状态 --&gt; &lt;a href=&quot;javascript:;&quot; @click.prevent=&quot;componentId=&#39;login&#39;&quot;&gt;登录&lt;/a&gt; &lt;a href=&quot;javascript:;&quot; @click.prevent=&quot;componentId=&#39;register&#39;&quot;&gt;注册&lt;/a&gt; &lt;component :is=&quot;componentId&quot;&gt;&lt;/component&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&#39;login&#39;, { template: &#39;&lt;h3&gt;登录组件&lt;/h3&gt;&#39; }); Vue.component(&#39;register&#39;, { template: &#39;&lt;h3&gt;注册组件&lt;/h3&gt;&#39; }); var vm = new Vue({ el: &quot;#box&quot;, data: { componentId: &#39;login&#39; // 默认显示登录 }, methods: {} }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 为组件切换添加过渡： 很简单，只需要用 transition 将 component 包裹起来即可。 &lt;transition&gt; &lt;component :is=&quot;componentId&quot;&gt;&lt;/component&gt; &lt;/transition&gt; 示例： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./lib/animate.css&quot;&gt; &lt;style&gt; .loginDiv { width: 200px; height: 200px; background-color: red; } .registerDiv { width: 200px; height: 200px; background-color: blue; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;!-- 给a注册点击事件，切换flag状态 --&gt; &lt;a href=&quot;javascript:;&quot; @click.prevent=&quot;componentId=&#39;login&#39;&quot;&gt;登录&lt;/a&gt; &lt;a href=&quot;javascript:;&quot; @click.prevent=&quot;componentId=&#39;register&#39;&quot;&gt;注册&lt;/a&gt; &lt;transition mode=&quot;out-in&quot; enter-active-class=&quot;animated bounceInRight&quot; leave-active-class=&quot;animated bounceOutRight&quot;&gt; &lt;component :is=&quot;componentId&quot;&gt;&lt;/component&gt; &lt;/transition&gt; &lt;/div&gt; &lt;template id=&quot;login&quot;&gt; &lt;div class=&quot;loginDiv&quot;&gt; &lt;/div&gt; &lt;/template&gt; &lt;template id=&quot;register&quot;&gt; &lt;div class=&quot;registerDiv&quot;&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; Vue.component(&#39;login&#39;, { template: &#39;#login&#39; }); Vue.component(&#39;register&#39;, { template: &#39;#register&#39; }); var vm = new Vue({ el: &quot;#box&quot;, data: { componentId: &#39;login&#39; }, methods: {} }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; mode=&quot;out-in&quot;：可以设置切换组件的模式为先退出再进入。 四、组件传值1、父组件向子组件传值我们先通过一个例子看看子组件可不可以直接访问父组件的数据： &lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;mycom&gt;&lt;/mycom&gt; &lt;/div&gt; &lt;template id=&quot;temp&quot;&gt; &lt;h3&gt;子组件 --- {{msg}}&lt;/h3&gt; &lt;/template&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#box&quot;, data: { msg: &#39;父组件的msg&#39; }, methods: {}, components: { mycom: { template: &#39;#temp&#39; } } }); &lt;/script&gt; &lt;/body&gt; 由于 components 定义的是私有组件，我们直接在子组件中调用父组件的msg会报错。 那么，怎么让子组件使用父组件的数据呢？ 父组件可以在引用子组件的时候， 通过 属性绑定（v-bind:） 的形式, 把需要传递给子组件的数据，以属性绑定的形式，传递到子组件内部，供子组件使用 。 &lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;mycom v-bind:parentmsg=&quot;msg&quot;&gt;&lt;/mycom&gt; &lt;/div&gt; &lt;template id=&quot;temp&quot;&gt; &lt;h3&gt;子组件 --- 父组件：{{parentmsg}}&lt;/h3&gt; &lt;/template&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#box&quot;, data: { msg: &#39;父组件的msg&#39; }, methods: {}, components: { mycom: { template: &quot;#temp&quot;, // 对传递给子组件的数据进行声明，子组件才能使用 props: [&#39;parentmsg&#39;] } } }); &lt;/script&gt; &lt;/body&gt; 注意：父组件绑定的属性名称不能有大写字母，否则不会显示，并且在命令行会有提示： 组件data数据和props数据的区别： data数据是子组件私有的，可读可写； props数据是父组件传递给子组件的，只能读，不能写。 案例：发表评论功能 父组件为评论列表，子组件为ID，评论者，内容和按钮的集合，在输入ID，评论者等内容，然后点击添加的时候，需要首先获取子组件的list列表，然后再添加新的列表项到列表中。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;mycom :plist=&quot;list&quot;&gt;&lt;/mycom&gt; &lt;ul&gt; &lt;li v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt; ID:{{item.id}} --- 内容：{{item.content}} --- 评论人：{{item.user}} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;template id=&quot;tmp1&quot;&gt; &lt;div&gt; &lt;label&gt; ID: &lt;input type=&quot;text&quot; v-model=&quot;id&quot;&gt; &lt;/label&gt; &lt;br&gt; &lt;label&gt; 评论者: &lt;input type=&quot;text&quot; v-model=&quot;user&quot;&gt; &lt;/label&gt; &lt;br&gt; &lt;label&gt; 内容: &lt;textarea v-model=&quot;content&quot;&gt;&lt;/textarea&gt; &lt;/label&gt; &lt;br&gt; &lt;!-- 把父组件的数据作为子组件的函数参数传入 --&gt; &lt;input type=&quot;button&quot; value=&quot;添加评论&quot; @click=&quot;addContent(plist)&quot;&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#box&quot;, data: { list: [{ id: Date.now(), user: &#39;user1&#39;, content: &#39;what&#39; }, { id: Date.now(), user: &#39;user2&#39;, content: &#39;are&#39; }] }, methods: {}, components: { mycom: { template: &#39;#tmp1&#39;, data: function () { return { id: &#39;&#39;, user: &#39;&#39;, content: &#39;&#39;, } }, methods: { addContent(plist) { plist.unshift({ id: this.id, user: this.user, content: this.content }); } }, props: [&#39;plist&#39;] } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 把添加ID，评论人，内容作为子组件，把列表作为父组件，然后把添加的数据放到父组件列表上，由于要获取到父组件列表的数据，所以必然涉及到父组件向子组件传值的过程。这里还通过子组件方法参数来保存父组件的数据到子组件的数据中。 2、父组件向子组件传方法既然父组件可以向子组件传递数据，那么也可以向子组件传递方法。 &lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;mycom v-bind:parentmsg=&quot;msg&quot; @parentfunc=&quot;show&quot;&gt;&lt;/mycom&gt; &lt;/div&gt; &lt;template id=&quot;temp&quot;&gt; &lt;div&gt; &lt;input type=&quot;button&quot; value=&quot;调用父组件方法&quot; @click=&quot;sonClick&quot;&gt; &lt;h3&gt;子组件 --- 父组件：{{parentmsg}}&lt;/h3&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#box&quot;, data: { msg: &#39;父组件的msg&#39; }, methods: { show(data1, data2) { console.log(&quot;这是父组件的show方法&quot; + data1 + data2); } }, components: { mycom: { template: &quot;#temp&quot;, // 对传递给子组件的数据进行声明，子组件才能使用 props: [&#39;parentmsg&#39;], methods: { sonClick() { // 调用父组件的show方法 this.$emit(&quot;parentfunc&quot;, 111, 222); } } } } }); &lt;/script&gt; &lt;/body&gt; 1、@parentfunc=&quot;show&quot; 绑定父组件的show方法。 2、&lt;input type=&quot;button&quot; value=&quot;调用父组件方法&quot; @click=&quot;sonClick&quot;&gt; 点击按钮调用父组件的show方法 3、在 子组件的 sonClick 方法中使用 this.$emit(&quot;parentfunc&quot;); 来调用父组件的show方法 4、父组件的show方法也可以传参，在调用的时候，实参从 this.$emit 的第二个参数开始传入。 5、如果 this.$emit 的第二个参数传的是子组件的data数据，那么父组件的方法就可以获得子组件的数据，这也是把子组件的数据传递给父组件的方式。 3、使用 ref 获取DOM和组件的引用我们知道Vue不推荐直接获取DOM元素，那么在Vue里面怎么获取DOM及组件元素呢？ 我们呢可以在元素上使用 ref 属性来获取元素。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;获取元素&quot; @click=&quot;getrefs&quot; ref=&quot;mybtn&quot;&gt; &lt;h3 ref=&quot;myh3&quot;&gt;这是H3&lt;/h3&gt; &lt;mycom ref=&quot;mycom&quot;&gt;&lt;/mycom&gt; &lt;/div&gt; &lt;template id=&quot;tmp1&quot;&gt; &lt;/template&gt; &lt;script&gt; // 定义组件 Vue.component(&#39;mycom&#39;, { template: &#39;#tmp1&#39;, data: function () { return { msg: &#39;子组件的msg&#39;, pmsg: &#39;&#39; } }, methods: { show(data) { console.log(&#39;调用子组件的show&#39;); this.pmsg = data; console.log(this.pmsg); }, } }); var vm = new Vue({ el: &quot;#box&quot;, data: { parentmsg: &#39;父组件的msg&#39; }, methods: { getrefs() { console.log(this.$refs.myh3); console.log(this.$refs.mycom.msg); this.$refs.mycom.show(this.parentmsg); } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 总结： 1、ref 属性不仅可以获取DOM元素，也可以获取组件（无论全局还是私有组件）元素。 2、获取到组件元素后，就可以获取组件元素的data数据和methods方法。 3、获取到组件中的方法后，可以传入VM的data数据，就可以把VM的data数据传入组件中。","categories":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}]},{"title":"grunt","slug":"grunt","date":"2018-11-09T03:22:55.000Z","updated":"2019-04-09T05:30:51.134Z","comments":true,"path":"2018/11/09/grunt/","link":"","permalink":"http://fudaqiang.com/2018/11/09/grunt/","excerpt":"","text":"一、Grunt介绍Grunt 中文主页 : http://www.gruntjs.net/ Grunt 是一套前端自动化构建工具，一个基于nodeJs的命令行工具。 它是一个任务运行器, 配合其丰富强大的插件 注意：Grunt 不支持 ES6 语法。如果要使用，需要先转化成 ES5 语法，再使用 Grunt。 常用功能: 合并文件(js/css) 压缩文件(js/css) 语法检查(js) less/sass预编译处理 其它… 二、Grunt 使用步骤1、安装nodejs // 查看版本 node -v 2、创建一个简单的应用 grunt 项目。 下面是目录的结构： |- build----------构建生成的文件所在的文件夹 |- src------------源码文件夹 |- js---------------js源文件夹 |- css--------------css源文件夹 |- index.html-----页面文件 |- Gruntfile.js---grunt配置文件(注意首字母大写) |- package.json---项目包配置文件 { &quot;name&quot;: &quot;grunt_test&quot;, &quot;version&quot;: &quot;1.0.0&quot; } 注意：package.json 中 name 的值 只能包含小写字母数字和中划线，如果为空则使用项目文件夹名称代替。 3、安装 grunt 此命令会自动生成 node-modules 文件夹。 全局安装 grunt-cli npm install -g grunt-cli 项目安装 grunt npm install grunt --save-dev 为什么全局安装 grunt 后还要局部安装 grunt？ 全局安装的 grunt 是在命令行中用的，项目中的 grunt 是调用 插件 或者自身的命令用的，名称相同，作用不同，缺一不可。 package.json和package-lock.json的区别： 自npm 5.0版本发布以来，npm istall的规则发生了三次变化: 1.npm 5.0.x版本，不管package.json怎么变，npm install时都会根据package-lock.json下载； 2.npm 5.1.0版本后，npm install会无视package-lock.json,下载最新的版本； 3.npm 5.4.2版本后， 如果package.json与package-lock.json不一致，npm install会根据package.json去下载版本，并更新package-lock.json； 如果package.json与package-lock.json一致，npm install会根据package-lock.json去下载。 4、运行构建项目命令 grunt 提示：Fatal error: Unable to find Gruntfile. 说明我们没有添加 Gruntfile.js 文件，在执行 grunt 命令的时候，会先找 Gruntfile.js 文件，这文件里面描述的是要执行什么任务。 5、配置文件: Gruntfile.js 此配置文件本质就是一个node函数类型模块 配置编码包含3步: 初始化插件配置 加载插件任务 注册构建任务 基本编码（下面是以 uglify 插件为例），grunt 的任务执行其实并不是本身执行任务，而是调用旗下各种插件来执行各种任务。grunt 就像一个大脑一样，只是起到指挥作用: module.exports = function(grunt) { // 1、初始化插件配置 grunt.initConfig({ pkg: grunt.file.readJSON(&#39;package.json&#39;), uglify: { options: { banner: &#39;/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&gt; */\\n&#39; }, build: { src: &#39;src/&lt;%= pkg.name %&gt;.js&#39;, dest: &#39;build/&lt;%= pkg.name %&gt;.min.js&#39; } } }); // 2、加载任务的插件。 grunt.loadNpmTasks(&#39;grunt-contrib-uglify&#39;); // 3、注册构建任务 grunt.registerTask(&#39;default&#39;, [&#39;uglify&#39;]); }; 此配置可以在官网找到： 再次执行命令: grunt ——– 提示成功, 但没有任何效果(还没有使用插件定义任务，我们将其注释掉了) 三、Grunt插件grunt官网的插件列表页面 http://www.gruntjs.net/plugins 插件分类: grunt团队贡献的插件 : 插件名大都以contrib-开头 第三方提供的插件 : 大都不以contrib-开头 常用的插件: grunt-contrib-clean——清除文件(打包处理生成的) grunt-contrib-concat——合并多个文件的代码到一个文件中 grunt-contrib-uglify——压缩js文件 grunt-contrib-jshint——javascript语法错误检查； grunt-contrib-cssmin——压缩/合并css文件 grunt-contrib-htmlmin——压缩html文件 grunt-contrib-imagemin——压缩图片文件(无损) grunt-contrib-copy——复制文件、文件夹 grunt-contrib-requirejs——合并压缩requirejs管理的所有js模块文件 grunt-contrib-watch——实时监控文件变化、调用相应的任务重新执行 四、JS 插件使用1、合并js注意：每个插件在使用的时候，都需要单独下载。 下面以合并js: 使用concat插件为例： 1、下载concat插件: npm install grunt-contrib-concat --save-dev 2、编写两个js文件: src/js/test1.js (function () { function add(num1, num2) { return num1 + num2; } console.log(add(10, 20)); })(); src/js/test2.js (function () { var arr = [2,3,4].map(function (item, index) { return item+1; }); console.log(arr); })(); 3、配置: Gruntfile.js 配置任务:（这个可以在官网查到插件的使用，然后进行适当路径的修改） concat: { options: { //可选项配置 separator: &#39;;&#39; //使用;连接合并 }, build: { //此名称任意 src: [&quot;src/js/*.js&quot;], //合并哪些js文件 dest: &quot;build/js/built.js&quot; //输出的js文件 } } 加载插件: grunt.loadNpmTasks(&#39;grunt-contrib-concat&#39;); 注册任务 grunt.registerTask(&#39;default&#39;, [&#39;concat&#39;]); 执行命令: grunt concat（或者直接使用grunt，会按顺序自动执行任务列表的任务。） 2、压缩js1、下载uglify插件 npm install grunt-contrib-uglify --save-dev 2、配置: Gruntfile.js 配置任务: pkg : grunt.file.readJSON(&#39;package.json&#39;), uglify : { options: { //不是必须的 banner: &#39;/*! &lt;%= pkg.name %&gt; - v&lt;%= pkg.version %&gt; - &#39; + &#39;&lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&gt; */&#39; }, build: { files: { &#39;build/js/built-&lt;%=pkg.name%&gt;-&lt;%=pkg.version%&gt;.min.js&#39;: [&#39;build/js/built.js&#39;] } } } 加载任务: grunt.loadNpmTasks(&#39;grunt-contrib-uglify&#39;); 注册任务: grunt.registerTask(&#39;default&#39;, [&#39;concat&#39;, &#39;uglify&#39;]); 执行任务: grunt uglify（或者直接使用grunt，会按顺序自动执行任务列表的任务。先执行 concat，再执行uglify） 压缩后的文件： 上面的注释就是 uglify 里面的 options 对应的输出内容。 可以看到，我们的test1.js 直接压缩成了 console.log(30);厉害了！ 需要注意的是：直接使用grunt，会按顺序自动执行任务列表的任务。先执行 concat，再执行uglify，这就说明 Grunt 是同步执行任务的。 3、js语法检查1、下载jshint插件: npm install grunt-contrib-jshint --save-dev 2、依赖文件: .jshintrc 由于 js 语法检查，是需要指定一些规则的，这些规则都写在 .jshintrc中，所以我们要先编写好 .jshintrc文件。 { &quot;curly&quot;: true, &quot;eqeqeq&quot;: true, &quot;eqnull&quot;: true, &quot;expr&quot; : true, &quot;immed&quot;: true, &quot;newcap&quot;: true, &quot;noempty&quot;: true, &quot;noarg&quot;: true, &quot;regexp&quot;: true, &quot;browser&quot;: true, &quot;devel&quot;: true, &quot;node&quot;: true, &quot;boss&quot;: false, //不能使用未定义的变量 &quot;undef&quot;: true, //语句后面必须有分号 &quot;asi&quot;: false, //预定义不检查的全局变量 &quot;predef&quot;: [ &quot;define&quot;, &quot;BMap&quot;, &quot;angular&quot;, &quot;BMAP_STATUS_SUCCESS&quot;] } 注意：最后的注释要去掉，因为 json 里面不允许有注释。 3、修改src/js/test1.js (function () { function add(num1, num2) { return num1 + num2 } console.log(add(10, 20)); })(); 4、配置 : Gruntfile.js 配置任务: jshint : { options: { jshintrc : &#39;.jshintrc&#39; //指定配置文件 }, build : [&#39;Gruntfile.js&#39;, &#39;src/js/*.js&#39;] //指定检查的文件 } 加载任务: grunt.loadNpmTasks(&#39;grunt-contrib-jshint&#39;); 注册任务: grunt.registerTask(&#39;default&#39;, [&#39;concat&#39;, &#39;uglify&#39;, &#39;jshint&#39;]); 执行命令: grunt //提示语句后未加分号 --&gt;修改后重新编译 五、CSS 插件使用1、合并压缩css1、下载cssmin插件: npm install grunt-contrib-cssmin --save-dev 2、先编写好两个css文件: test1.css #box1 { width: 100px; height: 100px; background: red; } test2.css #box2 { width: 200px; height: 200px; background: blue; } ​ 3、配置 : Gruntfile.js 配置任务: cssmin:{ options: { shorthandCompacting: false, roundingPrecision: -1 }, build: { files: { &#39;build/css/output.min.css&#39;: [&#39;src/css/*.css&#39;] } } } 加载任务: grunt.loadNpmTasks(&#39;grunt-contrib-cssmin&#39;); 注册任务: grunt.registerTask(&#39;default&#39;, [&#39;concat&#39;, &#39;uglify&#39;, &#39;jshint&#39;, &#39;cssmin&#39;]); 执行任务: grunt //在dist/css/下生成dist.min.css 我们可以发现：cssmin 其实不止进行了压缩操作，还进行了合并操作。 六、使用watch插件之前，我们每次修改js 或者css文件之后，都会进行一次grunt 指令的操作，这样太麻烦了，有没有一种方法可以在我们丢改了js 或者css文件之后，自动进行 grunt 的操作呢？watch 插件可以做到真正的自动化构建项目。 1、下载watch插件: npm install grunt-contrib-watch --save-dev 2、配置 : Gruntfile.js 配置任务: files：表示监视的是哪些文件 tasks：表示这些文件改变后，应该执行哪些任务 options：一些配置。spawn : false；表示变量更新，只对那些修改了的源文件执行任务，而不需要把所有的任务重新执行一遍，相当于C语言单文件编译和全部编译的区别。 watch : { scripts : { files : [&#39;src/js/*.js&#39;, &#39;src/css/*.css&#39;], tasks : [&#39;concat&#39;, &#39;jshint&#39;, &#39;uglify&#39;, &#39;cssmin&#39;], options : {spawn : false} } } 加载任务: grunt.loadNpmTasks(&#39;grunt-contrib-watch&#39;); 注册任务: grunt.registerTask(&#39;default&#39;, [&#39;concat&#39;, &#39;uglify&#39;, &#39;jshint&#39;, &#39;watch&#39;]); 上面这种写法会在cmd下一直等待源文件的改变，无法停止。而我们在需要项目上线的时候，只需要执行一次任务即可，所以我们可以专门定义一个任务来监听源文件的改变，而对于需要上线的项目，只需要像之前default任务一样执行一次就好了。 改进写法： grunt.registerTask(&#39;default&#39;, [&#39;concat&#39;, &#39;uglify&#39;, &#39;jshint&#39;]); grunt.registerTask(&#39;mywatch&#39;, [&#39;default&#39;,&#39;watch&#39;]); 注意：在执行监视任务的时候，一定要先执行default的任务，否则无法完成监视任务。 执行命令： grunt mywatch //控制台提示watch已经开始监听, 修改源文件保存后会自动编译处理","categories":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}]},{"title":"CommonJS、AMD、CMD、ES6","slug":"CommonJS、AMD、CMD、ES6","date":"2018-11-08T11:47:28.000Z","updated":"2019-04-09T05:33:47.442Z","comments":true,"path":"2018/11/08/CommonJS、AMD、CMD、ES6/","link":"","permalink":"http://fudaqiang.com/2018/11/08/CommonJS、AMD、CMD、ES6/","excerpt":"","text":"前端模块化：CommonJs、AMD、CMD、ES6 模块化的好处： 模块化的开发可以提升代码的可复用性，方便进行代码的管理。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。目前流行的js模块化规范有CommonJS、AMD、CMD、以及ES6的模块系统。 一、CommonJsnode.js是commonJS规范的主要实践者，它有四个重要的环境变量位为模块化的实现提供支持： module、exports、require、global。实际使用时，用module.exports定义当前模块对外输出的接口(不推荐直接用exports)，用require加载模块。 //定义模块math.js var num = 0; function add(a, b){ return a + b; } module.exports = { //在这里写需要向外暴露的函数、变量 add:add, num } //引用自定义的模块时，参数包含路径，可省略.js var math = require(&#39;./math&#39;) math.add(2,5) //7 //引用node-module包时，不需要带路径 var http = require(&#39;http&#39;) http.createService(()=&gt;{ }).listen(3000) CommonJS用同步的方法加载模块。在服务端，模块文化都存在本地磁盘，读取速度非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。 二、AMD和require.jsAMD规范采用异步方式加载模块，模块的加载不影响它后面的语句运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。这里介绍require.js实现AMD规范的模块化：用require.config()指定引用路径等，用define()定义模块，用require()加载模块。首先我们需要引入require.js文件和一个入口文件main.js中配置require.config()并规定项目中用到等基础模块 /*网页中引入ruire.js及main.js*/ &lt;script src=&quot;require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt; /* main.js 入口文件/主模块*/ require.config({ baseUrl: &quot;js/lib&quot;, //基路径 path:{ &quot;jquery&quot;:&quot;jquery.min&quot;, //实际路径js/lib/jquery.min.js &quot;underscore&quot;:&quot;underscore.min&quot; } }); // 执行基本操作 require([&quot;jquery&quot;,&quot;underscore&quot;],function($,un){ //some code here }) 引用模块的时候，我们将模块名放在[]中作为require()的第一个参数；如果我们定义的模块本身也依赖其他模块，那就需要将他们放在[]中作为define()的第一个参数。 //定义math.js define(function(){ var basicNum = 0; var add = function(x, y){ return x + y; }; return { add: add, basicNum: basicNum }; }); //定义一个依赖underscore.js 模块 defind([&#39;underscore&#39;],function(nu){ var classify = function(list){ nu.conntBy(list,function(num){ return num &gt; 30 ? &#39;old&#39; : &#39;young&#39;; }) }; return{ classify: classify }; }) //引用模块，将模块放在[]内 require([&#39;jquery&#39;,&#39;math&#39;],function($,m){ var sum = math.add(1,2); $(&quot;#box&quot;).html(sum) }); 三、CMD和sea.jsrequire.js在申明依赖的模块时会在第一之间加载并执行模块内的代码： define([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;],function(a,b,c){ //在最前面声明并初始化了要用到的所有模块 if(false){ //即便没用到某个模块，b 但在声明 b 时已经提前执行了 b.foo() } }) CMD是另一种js模块化方案，它于AMD很类似，不同点在于：AMD推崇依赖前置、提前执行，CMD推崇就近、延迟执行。此规范其实是在sea.js推广过程中产出的 //AMD写法 define([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;],function(a,b,c){ //在最前面声明并初始化了要用到的所有模块 if(false){ //即便没用到某个模块，b 但在声明 b 时已经提前执行了 b.foo() } }) //CMD写法 // 定义模块 math.js define(function(require,export,module){ var $ = require(&#39;jquery&#39;); var add = function(a,b){ return a + b; } exports.add = add; }) //加载模块 seajs.use([&#39;math.js&#39;],function(math){ var sum = math.add(1,2) }) AMD与CMD - 真正的不同 还是执行时间// AMD recommended define([&#39;a&#39;, &#39;b&#39;], function(a, b){ a.doSomething(); // 依赖前置，提前执行 b.doSomething(); }) // CMD recommanded define(function(require, exports, module){ var a = require(&quot;a&quot;); a.doSomething(); var b = require(&quot;b&quot;); b.doSomething(); // 依赖就近，延迟执行 }) 四、ES6 ModuleES6在语言标准的层面上，实现了模块功能，而且实现的相当简单，只为成为浏览器和服务器通用的模块定义方案。其模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。 /** 定义模块 math.js **/ var basicNum = 0 var add = function(a,b){ return a + b; }; export {basicNum, add}; // 抛出变量 export var PI = 3.14; export var bar = foo; //抛出 函数 export function foo(){ console.log(&#39;I am not bar.&#39;); } //默认抛出 一个js文件只能有一个默认抛出 export default (a, b)=&gt;{ return a + b } /** 引用模块 **/ import{basicNum, add } from &#39;./math&#39;; function test(el){ el.innerHTML = add(1,basicNum); } import { foo as bar } from &quot;./math&quot;; //as 设置别名 bar(); import * as math from &quot;./math&quot;; //*所有抛出 都配置到 math身上 math.PI math.foo() 如上例所示，使用import命令的时候，用户需要知道所要加载的变量名或函数名。其实ES6还提供了export default 命令，为模块指定默认输出，对应的import语句不需要使用大括号。这也更趋近于ADM的引用写法。 五、 ES6 模块与 CommonJS 模块的差异1. CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值的引用。 CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。 ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 2. CommonJS模块是运行时加载，ES6模块是在编译时输出接口 运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。 编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码， import 时采用静态命令的形式。即在 import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。","categories":[{"name":"技术 模块化","slug":"技术-模块化","permalink":"http://fudaqiang.com/categories/技术-模块化/"}],"tags":[],"keywords":[{"name":"技术 模块化","slug":"技术-模块化","permalink":"http://fudaqiang.com/categories/技术-模块化/"}]},{"title":"Vue指令","slug":"Vue指令","date":"2018-11-07T14:16:33.000Z","updated":"2019-04-09T05:32:36.033Z","comments":true,"path":"2018/11/07/Vue指令/","link":"","permalink":"http://fudaqiang.com/2018/11/07/Vue指令/","excerpt":"","text":"Vue 指令1、插值表达式插值表达式就是以双重大括号 ，类似 { {msg} } 的形式插入到 html 代码中。 1、插值表达式还可以进行简单的运算（比如加减乘除等），但是不能完全放置js代码。 2、插值表达式只能放在标签之间，而不能放在标签内部。 2、v-cloak在 使用 {{ msg }} 的方式插入数据的时候，如果网速特别慢的话， {{ msg } } 所代表的值不会立即显示出来，而会显示 这个字符串本身，怎么解决这个问题呢？ 使用 v-cloak 和 CSS 表达式结合，能够解决插值表达式闪烁的问题，这样会在网络未加载完时，不显示字符串本身。 示例： &lt;style&gt; [v-cloak] { display: none; } &lt;/style&gt; ... &lt;p v-cloak&gt; {`{ msg }`} &lt;/p&gt; 3、v-text默认 v-text 是没有闪烁问题的，但是 v-text 会覆盖元素中原本的内容，而 v-cloak 只会替换插值表达式，不会把 整个元素的内容清空。 &lt;span v-text=&quot;msg&quot;&gt;&lt;/span&gt; 4、v-htmlv-text 知识插入的纯文本格式内容，而 v-html 可以插入为 html 标签的代码，并解析出来。 &lt;span v-html=&quot;msg&quot;&gt;&lt;/span&gt; ... data: { msg: &#39;&lt;h1&gt;哈哈，我是一个大大的H1， 我大，我骄傲&lt;/h1&gt;&#39; }, 5、v-bindv-bind 是 Vue中，提供的用于绑定属性的指令。将一个属性的值变成动态值。 注意： v-bind: 指令可以被简写为: &lt;input type=&quot;button&quot; value=&quot;按钮&quot; v-bind:title=&quot;mytitle + &#39;123&#39;&quot;&gt; ... data: { mytitle: &#39;这是一个自己定义的title&#39; }, title 里面的内容就不是字符串了，而是会将 data 中的变量进行替换得到一个字符串整体。 6、v-onv-on ：给某个元素绑定事件监听函数。注意，函数必须封装在methods内。 注意：v-on: 指令可以被简写为@ &lt;input type=&quot;button&quot; value=&quot;按钮&quot; :title=&quot;mytitle + &#39;123&#39;&quot; v-on:click=&quot;show&quot;&gt; ... data: { mytitle: &#39;这是一个自己定义的title&#39; }, methods: { // 这个 methods属性中定义了当前Vue实例所有可用的方法 show: function () { alert(&#39;Hello&#39;) } } 案例：字体滚动播放 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;摇起来&quot; id=&quot;btn1&quot; @click=&quot;move&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;停下来&quot; id=&quot;btn2&quot; @click=&quot;stop&quot;&gt; &lt;h2 v-text=&quot;msg&quot;&gt;&lt;/h2&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#box&quot;, data: { msg: &quot;落霞与孤鹜齐飞，秋水共长天一色。&quot;, timeId: null }, methods: { move: function () { if (this.timeId != null) { clearInterval(this.timeId); } var that = this; this.timeId = setInterval(function () { var start = that.msg.substring(0, 1); var end = that.msg.substring(1); that.msg = end + start; }, 200); }, stop: function () { clearInterval(this.timeId); } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 注意： 1、在 VM 对象实例中，如果想要获取 data 上的数据，或者 想要调用 methods 中的 方法，必须通过 this.数据属性名 或 this.方法名 来进行访问，这里的 this，就表示 我们 new 出来的 VM 实例对象。 2、VM实例，会自动监听自己身上 data 中所有数据的改变，只要数据一发生变化，就会自动把最新的数据，从data 上同步到页面中去；【好处：程序员只需要关心数据，不需要考虑如何重新渲染DOM页面】 7、v-modelv-bind 只能实现数据的单向绑定，从 M 自动绑定到 V（即修改 data 的数据，自动同步到 html）， 无法实现数据的双向绑定。 使用 v-model 指令，可以实现 表单元素和 Model 中数据的双向数据绑定（不仅可以修改 data 的数据，自动同步到 html，也可以修改 html 的代码，同步到 data 数据）。 注意： v-model 只能运用在 表单元素中。 示例： &lt;input type=&quot;text&quot; style=&quot;width:100%;&quot; v-model=&quot;msg&quot;&gt; ... data: { msg: &#39;hello vue.&#39; }, 案例：简单的计算器 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;n1&quot;&gt; &lt;select v-model=&quot;opt&quot;&gt; &lt;option value=&quot;+&quot;&gt;+&lt;/option&gt; &lt;option value=&quot;-&quot;&gt;-&lt;/option&gt; &lt;option value=&quot;*&quot;&gt;*&lt;/option&gt; &lt;option value=&quot;/&quot;&gt;/&lt;/option&gt; &lt;/select&gt; &lt;input type=&quot;text&quot; v-model=&quot;n2&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;=&quot; @click=&quot;calc&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;result&quot;&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: &#39;#app&#39;, data: { n1: 0, n2: 0, result: 0, opt: &#39;+&#39; }, methods: { calc: function() { // 计算器算数的方法 // 逻辑： switch (this.opt) { case &#39;+&#39;: this.result = parseFloat(this.n1) + parseFloat(this.n2) break; case &#39;-&#39;: this.result = parseFloat(this.n1) - parseFloat(this.n2) break; case &#39;*&#39;: this.result = parseFloat(this.n1) * parseFloat(this.n2) break; case &#39;/&#39;: this.result = parseFloat(this.n1) / parseFloat(this.n2) break; } } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 8、v-for8.1、v-for 循环普通数组 我们之前如果要循环赋值给 p 标签 data中 list=[1,2,3,4,5,6]; 数组的话，会这样写： &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;{{list[0]}}&lt;/p&gt; &lt;p&gt;{{list[1]}}&lt;/p&gt; &lt;p&gt;{{list[2]}}&lt;/p&gt; &lt;p&gt;{{list[3]}}&lt;/p&gt; &lt;p&gt;{{list[4]}}&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { list: [1, 2, 3, 4, 5, 6] }, methods: {} }); &lt;/script&gt; &lt;/body&gt; 这样的话，就会很繁琐。而 v-for 会提供循环遍历 list 数组来给 p 标签赋值。如下： &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p v-for=&quot;(item, i) in list&quot;&gt;索引：{{i}} --- 项：{{item}}&lt;/p&gt; &lt;!-- 索引：0 --- 项：1 索引：1 --- 项：2 索引：2 --- 项：3 索引：3 --- 项：4 索引：4 --- 项：5 索引：5 --- 项：6 --&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { list: [1, 2, 3, 4, 5, 6] }, methods: {} }); &lt;/script&gt; &lt;/body&gt; 8.2、v-for 循环对象数组 &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p v-for=&quot;(user, i) in list&quot;&gt;Id：{{ user.id }} --- 名字：{{ user.name }} --- 索引：{{i}}&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { list: [ { id: 1, name: &#39;zs1&#39; }, { id: 2, name: &#39;zs2&#39; }, { id: 3, name: &#39;zs3&#39; }, { id: 4, name: &#39;zs4&#39; } ] }, methods: {} }); &lt;/script&gt; &lt;/body&gt; 8.3、v-for 循环对象 &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 注意：在遍历对象身上的键值对的时候， 除了 有 val key ,在第三个位置还有 一个 索引 --&gt; &lt;p v-for=&quot;(val, key, i) in user&quot;&gt;值是： {{ val }} --- 键是： {{key}} -- 索引： {{i}}&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { user: { id: 1, name: &#39;Tony Stark&#39;, gender: &#39;男&#39; } }, methods: {} }); &lt;/script&gt; &lt;/body&gt; 8.4、v-for 循环数字 &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- in 后面我们放过普通数组，对象数组，对象，还可以放数字 --&gt; &lt;p v-for=&quot;count in 10&quot;&gt;这是第 {{ count }} 次循环&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: &#39;#app&#39;, data: {}, methods: {} }); &lt;/script&gt; &lt;/body&gt; 注意：如果使用 v-for 迭代数字的话，前面的 count 值从 1 开始。 8.5、v-for 循环 key 属性 key 属性可以使得每一遍历的项是唯一的。 &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;label&gt;Id: &lt;input type=&quot;text&quot; v-model=&quot;id&quot;&gt; &lt;/label&gt; &lt;label&gt;Name: &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt; &lt;/label&gt; &lt;input type=&quot;button&quot; value=&quot;添加&quot; @click=&quot;add&quot;&gt; &lt;/div&gt; &lt;!-- 注意： v-for 循环的时候，key 属性只能使用 number或者string --&gt; &lt;!-- 注意： key 在使用的时候，必须使用 v-bind 属性绑定的形式，指定 key 的值 --&gt; &lt;!-- 在组件中，使用v-for循环的时候，或者在一些特殊情况中，如果 v-for 有问题，必须在使用 v-for 的同时，指定 唯一的 字符串/数字 类型 :key 值 --&gt; &lt;p v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt;{{item.id}} --- {{item.name}} &lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: &#39;#app&#39;, data: { id: &#39;&#39;, name: &#39;&#39;, list: [ { id: 1, name: &#39;李斯&#39; }, { id: 2, name: &#39;嬴政&#39; }, { id: 3, name: &#39;赵高&#39; }, { id: 4, name: &#39;韩非&#39; }, { id: 5, name: &#39;荀子&#39; } ] }, methods: { add() { // 添加方法 this.list.unshift({ id: this.id, name: this.name }) } } }); &lt;/script&gt; &lt;/body&gt; 9、v-if/v-showv-if 和 v-show 都可以控制元素的显示与否。但是实现原理不同。 v-if：决定某些元素是否存在 (加载性能更高,某个元素不需要被频繁切换时,则应该使用v-if) v-show：决定某些元素是否显示 (操作性能更高,如果某个元素需要被频繁切换,则应该使用v-show) v-if：每次都会重新删除或创建元素。 v-show ： 每次不会重新进行DOM的删除和创建操作，只是切换了元素的 display:none 样式。 所以，如果元素涉及到频繁的切换，最好不要使用 v-if, 而是推荐使用 v-show； 如果元素可能永远也不会被显示出来被用户看到，则推荐使用 v-if。 &lt;h3 v-if=&quot;true&quot;&gt;这是用v-if控制的元素&lt;/h3&gt; &lt;h3 v-show=&quot;true&quot;&gt;这是用v-show控制的元素&lt;/h3&gt; 有了v-if就有v-else-if和v-else v-if和v-show指令中除了可以放简单的值外，还可以放表达式： &lt;h3 v-if=&quot;age &lt; 18&quot;&gt;这是用v-if控制的元素&lt;/h3&gt; &lt;!--age是data中的一个属性--&gt; &lt;h3 v-else-if=&quot;age &lt; 28&quot;&gt;这是用v-if控制的元素&lt;/h3&gt; &lt;h3 v-else&gt;这是用v-if控制的元素&lt;/h3&gt; &lt;!--v-else不用写条件--&gt; 注意：v-if和v-else-if和v-else之间，不要加任何其他元素，否则会报错。","categories":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}]},{"title":"Vue的动画","slug":"Vue的动画","date":"2018-11-01T03:47:27.000Z","updated":"2019-04-09T05:32:22.305Z","comments":true,"path":"2018/11/01/Vue的动画/","link":"","permalink":"http://fudaqiang.com/2018/11/01/Vue的动画/","excerpt":"","text":"一、Vue的动画为什么要有动画：动画能够提高用户的体验，帮助用户更好的理解页面中的功能； Vue 中也有动画，不过远没有 css3 中的那么炫酷。只能有一些简单的变换，但是却可以配合第三方css动画库完成炫酷的变换。 1、过渡的类名在进入/离开的过渡中，会有 6 个 class 切换。 v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。 v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。 v-enter-to: 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。 v-leave: 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。 v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。 v-leave-to: 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。 要实现元素过渡，需要在添加过渡元素外边包裹上 &lt;transition&gt; &lt;/transition&gt; 闭合标签。 然后将 v-enter 和 v-leave-to 分为一组，v-enter-to 和v-leave分为一组，v-enter-active 和 v-leave-active 分为一组。 v-enter 和 v-leave-to 设置动画的起始状态； v-enter-to 和 v-leave 设置动画的结束状态； v-enter-active 和 v-leave-active 设置动画的过渡时间和过渡效果。 示例：点击按钮实现标签的淡入淡出： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .v-enter, .v-leave-to { opacity: 0; } .v-enter-active, .v-leave-active { transition: opacity 1s ease; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;显示/隐藏&quot; @click=&quot;flag=!flag&quot;&gt; &lt;transition&gt; &lt;h3 v-show=&quot;flag&quot;&gt;这是一个H3标签&lt;/h3&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#box&quot;, data: { flag: false }, methods: {} }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 注意事项： 1、发生动画的元素必须被 transition 标签包裹。 2、动画的进入离开为css属性，写在style标签中。 3、对于这些在过渡中切换的类名来说，如果你使用一个没有名字的 &lt;transition&gt;，则 v-是这些类名的默认前缀。如果你使用了 &lt;transition name=&quot;my-transition&quot;&gt;，那么 v-enter 会替换为my-transition-enter。 2、使用插件实现动画这里我们使用：Animate.css 第三方css插件。 官方网站：https://daneden.github.io/animate.css/ 使用方式： 1、引入 animate.css 库文件 2、在 tramsition 标签中使用特定动画的类样式。 &lt;transition enter-active-class=&quot;animated zoomIn&quot; leave-active-class=&quot;animated zoomOut&quot; :duration=&quot;{ enter: 200, leave: 400 }&quot;&gt; &lt;h3 v-show=&quot;flag&quot;&gt;这是一个H3标签&lt;/h3&gt; &lt;/transition&gt; 注意： 1、类样式一定要加基础类样式 animated 2、enter-active-class ：表示进入动画样式 leave-active-class：表示离开动画样式 :duration=&quot;{ enter: 200, leave: 400 }&quot;： 表示进入和离开的动画时间，单位ms。 如果只写 :duration=&quot;200&quot;则表示进入和离开的事件都为200ms。 3、半程动画有的时候我们只想实现动画的进入，不想实现动画的退出。比如将物品加入购物车的动画，会有一个商品掉入购物车的动画效果，但是我们却不需要商品再从购物车出来的动画效果，那么如何实现动画的半程效果呢？ 使用 JavaScript 钩子函数：（写在 transition 标签中） &lt;transition v-on:before-enter=&quot;beforeEnter&quot; v-on:enter=&quot;enter&quot; v-on:after-enter=&quot;afterEnter&quot; v-on:enter-cancelled=&quot;enterCancelled&quot; v-on:before-leave=&quot;beforeLeave&quot; v-on:leave=&quot;leave&quot; v-on:after-leave=&quot;afterLeave&quot; v-on:leave-cancelled=&quot;leaveCancelled&quot; &gt; &lt;!-- ... --&gt; &lt;/transition&gt; 其中上面四个事件是进如动画的几个阶段： before-enter ：动画进入之前的状态 enter：动画进入结束时的状态 after-enter：动画进入完成后的操作。 enter-cancelled：动画进入中断的操作（一般不使用） 既然是事件绑定函数，那么就有需要在 methods 中填写对应的事件处理函数： methods: { // -------- // 进入中 // -------- beforeEnter: function (el) { // ... }, enter: function (el, done) { // ... done() }, afterEnter: function (el) { // ... } 其中： 1、参数 el 表示的是需要动画操作的 原生DOM对象。 2、当只用 JavaScript 过渡的时候，在 enter 和 leave 中必须使用 done 进行回调。enter中的done参数就相当于进入动画中的 afterEnter 函数，可以避免动画完成后的延迟。 3、这些钩子函数可以结合 CSS transitions/animations 使用，也可以单独使用。 模拟商品掉入购物车过程 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .ball { width: 20px; height: 20px; border-radius: 50%; background-color: blue; margin-top: 10px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;快到碗里来&quot; @click=&quot;flag = !flag&quot;&gt; &lt;transition @before-enter=&quot;beforeEnter&quot; @enter=&quot;enter&quot; @after-enter=&quot;afterEnter&quot;&gt; &lt;div class=&quot;ball&quot; v-show=&quot;flag&quot;&gt;&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#box&quot;, data: { flag: false }, methods: { beforeEnter(el) { el.style.transform = &quot;translate(0, 0)&quot;; }, enter(el, done) { // 这句话，没有实际的作用，但是，如果不写，出不来动画效果； el.offsetWidth; el.style.transform = &quot;translate(100px, 400px)&quot;; el.style.transition = &#39;transform 1s&#39;; // 不使用的话，小圆点会停留一段时间才消失，不能立即调用 afterEnter 函数 done(); }, afterEnter(el) { this.flag = !this.flag; } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 1、enter 中的 el.offsetWidth; 无实际作用，可以认为 el.offset系列语句会强制动画刷新。 2、done(); 必须使用，相当于立即调用 afterEnter 函数。 3、既然是半程动画，那么意味着点击按钮的时候，每次小球都是从起始位置出发，而不会从终点位置回到其实位置的过程。 4、列表动画列表增加，删除项的时候，显示动画效果。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;style&gt; li { width: 100%; border: 1px dashed #aaa; margin: 10px 0; font: 700 12px/36px &#39;Microsoft YaHei&#39;; padding-left: 10px; } li:hover { border: 1px solid rgb(226, 22, 124); transition: border .5s; } /* 只对transition-group包裹的起作用*/ .v-enter, .v-leave-to { opacity: 0; transform: translateY(-10px); } .v-enter-active, .v-leave-active { transition: transform 0.5s ease-out; } /*列表的过渡更加平缓柔和*/ .v-move { transition: all 0.5s; } /*列表的过渡更加平缓柔和*/ .v-leave-active { position: absolute; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;div&gt; &lt;label for=&quot;&quot;&gt; ID: &lt;input type=&quot;text&quot; v-model=&quot;id&quot;&gt; &lt;/label&gt; &lt;label for=&quot;&quot;&gt; name: &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt; &lt;/label&gt; &lt;input type=&quot;button&quot; value=&quot;添加&quot; @click=&quot;add&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;ul&gt; &lt;!-- 1、使用transition-group包裹v-for渲染的li列表 --&gt; &lt;transition-group appear&gt; &lt;li v-for=&quot;(item, index) in list&quot; :key=&quot;item.id&quot; @click=&quot;del(index)&quot;&gt; {{item.id}} --- {{item.name}} &lt;/li&gt; &lt;/transition-group&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#box&quot;, data: { id: &#39;&#39;, name: &#39;&#39;, list: [{ id: 1, name: &#39;漩涡鸣人&#39; }, { id: 2, name: &#39;宇智波佐助&#39; }, { id: 3, name: &#39;旗木卡卡西&#39; }, { id: 4, name: &#39;自来也&#39; }, ] }, methods: { add() { this.list.push({ id: this.id, name: this.name }); }, del(id) { this.list.splice(id, 1); } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 注意： 1、在实现列表过渡的时候，如果需要过渡的元素，是通过 v-for 循环渲染出来的，不能使用 transition 包裹，需要使用 transition-group. 2、如果要为 v-for 循环创建的元素设置动画，必须为每一个 元素 设置 :key 属性 3、过渡的类名：v-enter 等，这些类只对 transition 或者 transition-group 包裹起来的元素起作用。 4、&lt;transition-group&gt; 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 v-move 特性，它会在元素的改变定位的过程中应用。实现删除动画的时候，后一个元素补到删除元素的位置也能动画，v-move 和 v-leave-active 结合使用，能够让列表的过渡更加平缓柔和： .v-move { transition: all 0.5s; } .v-leave-active { position: absolute; } 5、给 transition 或者 transition-group 添加属性：appear 可以实现页面开始加载的时候，实现动画效果。 我们发现一个问题就是，transition-group 会被默认当做 span 标签，这不是我们想要的样子鸭。 通过 为 transition-group 元素，设置 tag 属性，指定 transition-group 渲染为指定的元素，如果不指定 tag 属性，默认渲染为 span 标签，这就不符合语义了。所以我们可以把外层的 ul 去掉，然后加上tag=&quot;ul&quot;来把 transition-group 标签作为 ul 标签。","categories":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}]},{"title":"Webpack","slug":"Webpack","date":"2018-10-12T02:01:13.000Z","updated":"2019-04-09T05:31:31.281Z","comments":true,"path":"2018/10/12/Webpack/","link":"","permalink":"http://fudaqiang.com/2018/10/12/Webpack/","excerpt":"","text":"##一、Webpack介绍 Webpack 中文官网 https://www.webpackjs.com/ 1、什么是webpack?Webpack是一个模块打包器(bundler)。 但是，webpack的核心功能是： 把模块化规范的代码，比如commonJS等编译成浏览器能识别的代码输出出来(也叫作前端模块化) 我们知道在之前，commonJS规范的代码只能在node后端中运行（node是原生支持commonJS模块化的），如果在前端使用的话，会报一个错误：‘require is not defined’ 找不到require，这就是模块化规范的代码不能在浏览器中解析运行，如果想运行，达到前端模块化的功能，就要使用自动化构建工具，webpack就是其中的一种。 webpack的辅助功能才是对源代码的打包，压缩，混淆处理等。 所以一定要搞清楚主次关系。 在Webpack看来, 前端的所有资源文件(js/json/css/img/less/…)都会作为模块处理，每一个资源文件都是一个模块。它将根据模块的依赖关系进行静态编译，生成对应的静态资源。 webpack所有的配置都会写在项目根目录下的webpack.config.js 文件下。 webpack如何配置，你需要先理解四个核心概念： 入口(entry) 输出(output) loader 插件(plugins) 入口 指示 webpack 应该使用哪个模块作为主模块来构建静态资源，一般打包的时候只引入主模块，而在主模块中会引入其他的模块，这样我们就只需要打包一份主模块就够了。 Loader Webpack 本身只能加载JS/JSON模块，如果要加载其他类型的文件(模块)，就需要使用对应的loader 进行转换/加载 Loader 本身也是运行在 node.js 环境中的 JavaScript 模块 它本身是一个函数，接受源文件作为参数，返回转换的结果 loader 一般以 xxx-loader 的方式命名，xxx 代表了这个 loader 要做的转换功能，比如 json-loader。 配置文件(默认) webpack.config.js : 是一个node模块，返回一个 json 格式的配置信息对象 插件 插件件可以完成一些loader不能完成的功能。 插件的使用一般是在 webpack 的配置信息 plugins 选项中指定。 CleanWebpackPlugin: 自动清除指定文件夹资源 HtmlWebpackPlugin: 自动生成HTML文件并 UglifyJSPlugin: 压缩js文件 二、webpack初体验1、安装webpack由于现在webpack版本在2018年8月份的时候更新到 webpack 4+ 了，但是市面上用的最多的还是webpack3+，所以下面所有的示例均已webpack3+来演示。 如果想要使用 webpack3+ 的版本的话，在全局安装和局部安装的时候需要注意，需要在webpack后面加上@3 ，表示安装webpack3+ 的版本。 //全局安装 npm install webpack@3.11.0 -g //局部安装 npm install webpack@3.11.0 -D 全局安装时为了能够使用webpack指令来进行项目的编译等， 项目安装是为了使用webpack模块的内容。 2、初始化项目使用npm init -y 初始化项目。 -y的目的是不提示项目名等等提示信息，直接全部使用默认的配置创建package.json文件。 创建src目录，目录下建一个主模块main.js，在主模块中调用sayHello.js文件 // sayHello.js module.exports = name =&gt; { console.log(name); } // main.js let say = require(&#39;./sayHello&#39;); say(&#39;lone&#39;); 创建主页面 将来webpack打包生成的js文件是dist目录下的index.js文件 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;真的&lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt; &lt;/html&gt; 3、编译运行webpack main.js index.js 然后就可以在浏览器中查看打印出’lone’ 三、webpack打包有的时候我们希望将编译好的js文件放到指定的dist目录，但是我们又不想手工创建，有没有办法呢？ webpack.config.js配置文件可以解决。 1、新建一个webpack.config.js文件： module.exports = { entry: __dirname + &#39;/src/main.js&#39;, output: { path: __dirname + &#39;/dist&#39;, filename: &#39;index.js&#39; } } __dirname 表示当前项目的根路径。 entry 入口模块 output 输出的目标文件的路径和文件名 2、使用指令进行编译： webpack 之后我们会在项目更目录下发现一个dist目录，目录下有个index.js文件，就是我们的目标文件。 四、热加载（自动编译）每次在我们修改源文件后，都需要进行webpack指令进行打包才可以生成目标文件，才能在页面展示使用。 有没有在源代码修改保存后，自动编译成目标位文件刷新页面呢？ 这就是webpack-dev-server模块。webpack-dev-server模块会自动开启个本地web服务器来运行我们的程序，一旦源文件被修改，会自动同步到浏览器中。 webpack-dev-server模块原理： webpack-dev-server 其实就是个微服务器，在执行 webpack-dev-server 命令的时候，也会首先从 webpack.config.js 中找到任务，然后在其自己内部进行打包，打包好了之后，并不会输出到本地，而是在其内存中有一份 index.js ，我们通过 http://localhost:3000/ 访问的其实就是其内存中的文件，这时候即使我们删除本地 index.js 也不会影响页面的显示。 并且 webpack-dev-server 会自动寻找文件的路径，所以我们不需要指定 index.js 和 大图的路径，这也是其智能的地方。 但是需要注意的是，webpack-dev-server模块不会生成目标文件，也就是不会生成dist文件夹和里面的目标文件，webpack-dev-server会将编译运行放在内存的目标文件，而不会生成到项目中。而webpack指令才可以生成目标文件。 1、安装 webpack-dev-server模块 npm i webpack-dev-server@2.9.7 -g 注意安装2.9.7版本的。 2、在webpack.config.js中进行配置： // 安装的webpack-dev-server模块配置信息 devServer: { contentBase: __dirname + &#39;/dist&#39;, // 指定本地web服务器根路径 port: 3000, inline: true // 当源文件改变后，自动在浏览器页面刷新 } 3、运行指令 webpack-dev-server --inline --open 这时候，编译完成会自动访问http://localhost:3000 地址，就不用再打开浏览器了，如果项目源代码有修改，保存后，浏览器会自动进行刷新显示。 4、这个命令太长了，package.json就用到了。 &quot;scripts&quot;: { &quot;start&quot;: &quot;webpack-dev-server --inline --open&quot;, &quot;build&quot;: &quot;webpack&quot; } 以后直接使用指令： npm run start 想生成dist文件的时候： npm run build 五、html-webpack-plugin插件我们之前编译的dist文件夹只有index.js目标文件，其实我们在项目上线的时候，除了有js文件还应该有index.html 主文件，所以我们应该把html文件放到dist目录下。但是由于一般dist下的文件不建议修改，我们希望的是修改了源文件中的html就自动复制一份到dist中，html-webpack-plugin 插件就给我们提供了帮助。 1、安装html-webpack-plugin插件 npm i html-webpack-plugin -D 2、修改webpack.config.js配置文件 let Hwp = require(&#39;html-webpack-plugin&#39;); //.. // 安装的html-webpack-plugin模块的配置 plugins: [ new Hwp({ template: __dirname + &#39;/src/index.html&#39;, // 源文件index.html路径 filename: &#39;index.html&#39;, // 由于生成路径output已配置，这里只写生成的文件名 inject: true // 在index.html中自动引入需要的就js,css文件 }) ] html-webpack-plugin插件还有个额外功能就是 inject: true，它可以自动识别需要引入的script和link文件，特别好使。 3、重启服务 六、打包css到js项目还存在css文件怎么办？可以把css样式打包到js中。 1、安装模块 css-loader和style-loader npm i css-loader style-loader -D css-loader：作用是读取css文件 style-loader：作用是将css注入到js中 2、配置config module: { rules: [{ test: /\\.css$/, // 解析以.css结尾的文件 loader: &#39;style-loader!css-loader&#39; //解析以.css结尾的文件需要用到的模块（注意：书写顺序是先使用的写后面） }] } 注意：loader: ‘style-loader!css-loader’ 中书写的顺序，先需要用到的写到后面。 3、在入口js引入css文件 // main.js require(&#39;./style/base.css&#39;); 4、重启服务 npm run start 七、打包图片文件到js1、安装插件 // 图片相关插件（url-loader是对象file-loader的上层封装，使用时需配合file-loader使用。） npm install file-loader url-loader -D 2、修改配置文件 module: { rules: [ { test: /\\.(png|jpg|gif)$/, use: [{ loader: &#39;url-loader&#39;, options: { limit: 8192 } }] } // 限制转换的图片大小为8Kb ] }, 3、在css中插入图片 div { width: 200px; height: 200px; background: url(../img/1.jpg); } 4、重新编译 我们发现dist中没有图片，但是图片显示了，说明图片注入到了css中。我们可以查看生成的index.css看出来，图片是以base64的形式存在的： div { width: 200px; height: 200px; background: url(data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAASA...（太长省略）BBHDPds2gKCBThSN3rYhi5J6mjNJ2FJSsB7Sn+cV82af8A8hGy/wCvq3/9GpX0BXFXgnM3hJ2P/9k=); } 注意：当我们设置的图片大小超过限时时，会在dist中产生一个图片，而不是base64形式的。 比如我把 limit: 1024 之后，重新webpack生成后会在dist下生成一个990384cd91d73b43929679287541587e.jpg图片，然后在css中引入的是这个图片，而不是base64。 div { width: 200px; height: 200px; background: url(990384cd91d73b43929679287541587e.jpg); } 七、开启地图资源模式之前把所有的js和css都编译到一个js里面之后，如果我们代码有运行错误，排错非常麻烦，因为生成的js文件非常长，可能报错的位置是在一万多行的位置，但是 实际上我们代码的位置只是在几十行的位置。这个该如何处理？ 这就需要我们开启地图资源模式。 开启的方式很简单，只需要在配置文件中加上下面一句话即可。 // 开启地图资源模式 devtool: &#39;source-map&#39; 此时，当我们使用webpack 生成目标文件的时候，会自动多出一个map文件，比如index.js.map 这个就是一个源文件和编译后目标文件的一个映射文件，当程序有错误的时候，提示的就是源文件的行号而不是目标文件的行号，方便错误定位。 我们可以在目标文件的最后发现有个映射文件的声明的注释，这个注释不能删除，否则就无法实现映射功能。 八、多入口文件之前的目标文件只有一个index.js，如何生成多个目标文件？ 我们需要在配置文件的entry属性配置成一个对象，这个对象有多个属性，分别对应多个目标文件。 entry: { index: __dirname + &#39;/src/main.js&#39;, goods: __dirname + &#39;/src/goods.js&#39; }, output: { path: __dirname + &#39;/dist&#39;, filename: &#39;[name].js&#39; }, entry中每个属性即为目标文件名，输出文件的[name].js中的name即为entry的属性名。 但是，现在一般都是单页面应用，所以像这种对入口文件的形式很少见了。 九、打包Less,Scss等下面以less为例。 1、安装loader npm i less-loader less -D 2、设置配置文件 module: { rules: [ {test: /\\.css$/,loader: &#39;style-loader!css-loader&#39;}, {test: /\\.less$/, loader: &#39;style-loader!css-loader!less-loader&#39; } ] }, 也是要注意书写顺序。 3、重启服务。 十、提取样式文件之前我们是把css样式打包到js文件中的，而js是使用script标签引入的页面的。 link标签与script的区别： link标签的加载时异步的，而script的加载会阻塞程序的运行，影响用户体验，所有有必要将css文件提取出来。 1、安装插件 npm i extract-text-webpack-plugin -D 2、修改配置 let Ext = require(&#39;extract-text-webpack-plugin&#39;); module: { rules: [ { test: /\\.css$/, loader: Ext.extract(&#39;css-loader&#39;) }, { test: /\\.less$/, loader: Ext.extract(&#39;css-loader!less-loader&#39;) } ] }, plugins: [ new Ext(&#39;index.css&#39;) ], 由于不需要注入到js中了，所以style-loader就去掉了，但读取less和css还是需要的，顺序也是需要的。 在plugins中也要new Ext，参数为生成的css目标文件名。 十一、ES6转换成ES5很多时候我们需要将ES6语法转换成ES5的，因为很多浏览器比如政府网站都比较老旧，不支持ES6语法。所以需要将ES6转换成ES5。 1、安装插件 npm i babel-loader@7.1.5 babel-core babel-preset-env -D 这三个插件： babel-loader@7.1.5 ：是一个babel工具 babel-core ：是工具的依赖 babel-preset-env：专门用来解析ES6到ES5的 2、修改配置文件 module: { rules: [ { test: /\\.css$/, loader: Ext.extract(&#39;css-loader&#39;) }, { test: /\\.less$/, loader: Ext.extract(&#39;css-loader!less-loader&#39;) }, { test: /\\.js$/, exclude: /node_modules/, loader: &#39;babel-loader?presets[]=env&#39; } ] }, exclude:除去node-modules文件夹里面的js文件 我们在loader:babel-loader中加了参数?presets[]=env，这只是临时写法。 一般写法是在项目根目录新建一个文件.babelrc: { &quot;presets&quot;:[&quot;env&quot;] } 和上面是等价的。 如果使用到ES6的高级语法，比如展开符...时，上面的插件就满足不了了，需要另一个插件： npm i babel-preset-stage-2 -D 然后修改.babelrc : { &quot;presets&quot;:[&quot;env&quot;, &quot;stage-2&quot;] } 3、在main.js书写测试代码 let obj = { name: &#39;daotin&#39;, age: 18 } let { name: user, age } = obj; console.log(user, age); 4、重启服务 十二、使用jquery方式一：在线cdn 方式二：下载jq，然后在html引入 方式三：安装插件 1、安装jq插件 npm i jquery -S 2、然后那个js文件需要，直接require引入 let $ = require(&#39;jquery&#39;); 这种方式有个缺陷就是，只能本文件使用jq，其他文件要使用，还得require一次，很多文件使用jq就得很多文件require，可不可以只引入一次所有的js都可用呢？ 3、设置jq全局作用域 let webpack = require(&#39;webpack&#39;); plugins: [ new webpack.ProvidePlugin({ $: &#39;jquery&#39; }) ], 4、重启服务即可。 ##十二、其他插件 webpack 插件： https://www.webpackjs.com/plugins/ https://webpack.docschina.org/plugins/ 1、常用的插件 使用html-webpack-plugin根据模板html生成新的html文件，并自动引入js文件到页面 使用clean-webpack-plugin清除dist文件夹 使用uglifyjs-webpack-plugin压缩打包的js文件 2、使用步骤1、下载 npm install --save-dev html-webpack-plugin clean-webpack-plugin uglifyjs-webpack-plugin 2、配置 const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); const CleanWebpackPlugin = require(&#39;clean-webpack-plugin&#39;); const UglifyJsPlugin = require(&#39;uglifyjs-webpack-plugin&#39;); module.exports = { entry: &#39;./src/js/entry.js&#39;, // 入口文件 output: { // 略 }, module: { // 略 }, devServer: { // 略 }, plugins: [ // template 表示模板的意思，表示以 &#39;./index.html&#39; 为模板创建一个html文件 // 新创建的html文件默认会生成在dist/js目录下，并自动引入bundle.js文件到页面 new HtmlWebpackPlugin({template: &#39;./index.html&#39;}), // 在打包的时候，先清空dist目录下的所有文件再生成相关文件 new CleanWebpackPlugin([&#39;dist&#39;]), // 将生成的bundle.js压缩 new UglifyJsPlugin() ] }; 3、打包运行项目 webpack 结果在 dist/js下自动生成index.html文件，并且自动引入bundle.js文件。","categories":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}]},{"title":"修饰符","slug":"修饰符","date":"2018-10-08T14:16:33.000Z","updated":"2019-04-09T03:45:36.807Z","comments":true,"path":"2018/10/08/修饰符/","link":"","permalink":"http://fudaqiang.com/2018/10/08/修饰符/","excerpt":"","text":"一、事件修饰符 .stop ： 阻止冒泡 .prevent ： 阻止默认事件（比如点击超链接，阻止跳转到默认网页） .capture ： 添加事件侦听器时使用事件捕获模式（与冒泡模式相反） .self ：只当事件在该元素本身（比如不是子元素）触发时触发回调 .once ：事件只触发一次，之后还原标签本身的行为。 示例： &lt;div id=&quot;app&quot;&gt; &lt;!-- 使用 .stop 阻止冒泡 --&gt; &lt;div class=&quot;inner&quot; @click=&quot;div1Handler&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;戳他&quot; @click.stop=&quot;btnHandler&quot;&gt; &lt;/div&gt; &lt;!-- 使用 .prevent 阻止默认行为（跳转到百度首页） --&gt; &lt;a href=&quot;http://www.baidu.com&quot; @click.prevent=&quot;linkClick&quot;&gt;有问题，先去百度&lt;/a&gt; &lt;!-- 使用 .capture 实现捕获触发事件的机制：跟冒泡相反，从外到里--&gt; &lt;div class=&quot;inner&quot; @click.capture=&quot;div1Handler&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;戳他&quot; @click=&quot;btnHandler&quot;&gt; &lt;/div&gt; &lt;!-- 使用 .self 实现只有点击当前元素时候，才会触发事件处理函数 --&gt; &lt;div class=&quot;inner&quot; @click.self=&quot;div1Handler&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;戳他&quot; @click=&quot;btnHandler&quot;&gt; &lt;/div&gt; &lt;!-- 使用 .once 只触发一次事件处理函数（如下案例只触发一次点击事件，之后还原标签本身的行为） --&gt; &lt;a href=&quot;http://www.baidu.com&quot; @click.prevent.once=&quot;linkClick&quot;&gt;有问题，先去百度&lt;/a&gt; &lt;/div&gt; .stop 和 .self 的区别： &lt;!-- stop 会阻止冒泡行为 --&gt; &lt;div class=&quot;outer&quot; @click=&quot;div2Handler&quot;&gt; &lt;div class=&quot;inner&quot; @click=&quot;div1Handler&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;戳他&quot; @click.stop=&quot;btnHandler&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- .self 只会阻止自己身上冒泡行为的触发，并不会真正阻止冒泡的行为 --&gt; &lt;div class=&quot;outer&quot; @click=&quot;div2Handler&quot;&gt; &lt;div class=&quot;inner&quot; @click.self=&quot;div1Handler&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;戳他&quot; @click=&quot;btnHandler&quot;&gt; &lt;/div&gt; &lt;/div&gt; 二、按键修饰符我们现在有个需求就是输入ID和name后不点击add按钮，而是按下回车键也需要添加到列表中。 我们可以在name输入框中加入按键抬起事件，并且指定是enter键抬起时才触发。 &lt;label for=&quot;name&quot;&gt; name: &lt;input type=&quot;text&quot; id=&quot;name&quot; v-model=&quot;name&quot; @keyup.enter=&quot;addClick&quot;&gt; .enter ： 就是按键修饰符。 系统提供的按键修饰符有： .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 如果我们想自定义其他的按键怎么办呢？ 通过Vue.config.keyCodes.f2 = 113; ；可以将f2作为按键修饰符添加到系统按键修饰符中。 具体每个按键的值是多少？下面是常见的按键的码。 keyCode 8 = BackSpace BackSpace keyCode 9 = Tab Tab keyCode 12 = Clear keyCode 13 = Enter keyCode 16 = Shift_L keyCode 17 = Control_L keyCode 18 = Alt_L keyCode 19 = Pause keyCode 20 = Caps_Lock keyCode 27 = Escape Escape keyCode 32 = space keyCode 33 = Prior keyCode 34 = Next keyCode 35 = End keyCode 36 = Home keyCode 37 = Left keyCode 38 = Up keyCode 39 = Right keyCode 40 = Down keyCode 41 = Select keyCode 42 = Print keyCode 43 = Execute keyCode 45 = Insert keyCode 46 = Delete keyCode 47 = Help keyCode 48 = 0 equal braceright keyCode 49 = 1 exclam onesuperior keyCode 50 = 2 quotedbl twosuperior keyCode 51 = 3 section threesuperior keyCode 52 = 4 dollar keyCode 53 = 5 percent keyCode 54 = 6 ampersand keyCode 55 = 7 slash braceleft keyCode 56 = 8 parenleft bracketleft keyCode 57 = 9 parenright bracketright keyCode 65 = a A keyCode 66 = b B keyCode 67 = c C keyCode 68 = d D keyCode 69 = e E EuroSign keyCode 70 = f F keyCode 71 = g G keyCode 72 = h H keyCode 73 = i I keyCode 74 = j J keyCode 75 = k K keyCode 76 = l L keyCode 77 = m M mu keyCode 78 = n N keyCode 79 = o O keyCode 80 = p P keyCode 81 = q Q at keyCode 82 = r R keyCode 83 = s S keyCode 84 = t T keyCode 85 = u U keyCode 86 = v V keyCode 87 = w W keyCode 88 = x X keyCode 89 = y Y keyCode 90 = z Z keyCode 96 = KP_0 KP_0 keyCode 97 = KP_1 KP_1 keyCode 98 = KP_2 KP_2 keyCode 99 = KP_3 KP_3 keyCode 100 = KP_4 KP_4 keyCode 101 = KP_5 KP_5 keyCode 102 = KP_6 KP_6 keyCode 103 = KP_7 KP_7 keyCode 104 = KP_8 KP_8 keyCode 105 = KP_9 KP_9 keyCode 106 = KP_Multiply KP_Multiply keyCode 107 = KP_Add KP_Add keyCode 108 = KP_Separator KP_Separator keyCode 109 = KP_Subtract KP_Subtract keyCode 110 = KP_Decimal KP_Decimal keyCode 111 = KP_Divide KP_Divide keyCode 112 = F1 keyCode 113 = F2 keyCode 114 = F3 keyCode 115 = F4 keyCode 116 = F5 keyCode 117 = F6 keyCode 118 = F7 keyCode 119 = F8 keyCode 120 = F9 keyCode 121 = F10 keyCode 122 = F11 keyCode 123 = F12 keyCode 124 = F13 keyCode 125 = F14 keyCode 126 = F15 keyCode 127 = F16 keyCode 128 = F17 keyCode 129 = F18 keyCode 130 = F19 keyCode 131 = F20 keyCode 132 = F21 keyCode 133 = F22 keyCode 134 = F23 keyCode 135 = F24 示例： &lt;input type=&quot;text&quot; id=&quot;name&quot; v-model=&quot;name&quot; @keyup.f2=&quot;addClick&quot;&gt; //... &lt;script&gt; Vue.config.keyCodes.f2 = 113; &lt;/script&gt;","categories":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}]},{"title":"javascript数组去重","slug":"javascript数组去重","date":"2018-10-08T12:03:06.000Z","updated":"2019-04-08T14:22:22.442Z","comments":true,"path":"2018/10/08/javascript数组去重/","link":"","permalink":"http://fudaqiang.com/2018/10/08/javascript数组去重/","excerpt":"","text":"set去重var arr = [5,3,1,2,&quot;c&quot;,&quot;a&quot;,3,4,5,&quot;c&quot;,1,&quot;b&quot;,2,&quot;a&quot;,3,2,1,4,5] var newSet = new Set(arr) console.log([...newSet]) Array.prototype.includes() var newArr = [] for (var i of arr) { if (!newArr.includes(i)) { newArr.push(i) } } console.log(newArr) 相邻元素去重var arr = [5,3,1,2,3,4,5,1,2,3,2,1,4,5] var ar = arr.sort((a, b) =&gt; { return a - b; }) for (var i = 0; i &lt; ar.length; i++) { for (var j = 0; j &lt; ar.length; j++) { if (ar[i] == ar[j + 1]) { ar.splice(i, 1) } } } console.log(ar) Array.prototype.reduce() var arr = [5,3,1,2,&quot;c&quot;,&quot;a&quot;,3,4,5,&quot;c&quot;,1,&quot;b&quot;,2,&quot;a&quot;,3,2,1,4,5] init = [] var result = arr.sort().reduce((init, current) =&gt; { console.log(init, current) if (init.length === 0 || init[init.length - 1] !== current) { init.push(current); } return init; }, []); console.log(result) 对象去重var arr = [5,3,1,2,&quot;c&quot;,&quot;a&quot;,3,4,5,&quot;c&quot;,1,&quot;b&quot;,2,&quot;a&quot;,3,2,1,4,5] var obj = {} for (var i of arr) { console.log(i) obj[i] = i } var brr = Object.values(obj) console.log(brr) filter 去重var arr = [5,3,1,2,&quot;c&quot;,&quot;a&quot;,3,4,5,&quot;c&quot;,1,&quot;b&quot;,2,&quot;a&quot;,3,2,1,4,5] function unique(arr) { return arr.filter((item, index, brr) =&gt; { return brr.indexOf(item) === index }) } console.log(unique(arr))","categories":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}]},{"title":"vue的watch、computed、methods的区别","slug":"vue的watch、computed、methods的区别","date":"2018-09-09T05:47:47.000Z","updated":"2019-04-09T05:48:53.825Z","comments":true,"path":"2018/09/09/vue的watch、computed、methods的区别/","link":"","permalink":"http://fudaqiang.com/2018/09/09/vue的watch、computed、methods的区别/","excerpt":"","text":"一、Vue的watch属性我们需要实现这样一个案例：有三个文本框，第一个文本框是姓，第二个文本框是名，第三个文本框是前两个文本框的组合。需求是当前两个文本框数据变化的时候，第三个文本框自动组合。 方式一： 可以给第一，二个文本框添加keyup 事件，监听按键的抬起事件，然后拼接出第三个文本框的内容。 &lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstname&quot; @keyup=&quot;keyup&quot;&gt; + &lt;input type=&quot;text&quot; v-model=&quot;lastname&quot; @keyup=&quot;keyup&quot;&gt; = &lt;input type=&quot;text&quot; v-model=&quot;fullname&quot;&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#box&quot;, data: { firstname: &#39;&#39;, lastname: &#39;&#39;, fullname: &#39;&#39; }, methods: { keyup() { this.fullname = this.firstname + &#39;·&#39; + this.lastname; } } }); &lt;/script&gt; &lt;/body&gt; 方式二： 使用vm实例的 watch 属性，可以监视 data 中指定数据的变化，然后触发这个 watch 中对应的 function 处理函数。 function 处理函数有两个参数： newVal：表示改变后的数据。 oldVal：表示改变之前的数据。 &lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstname&quot;&gt; + &lt;input type=&quot;text&quot; v-model=&quot;lastname&quot;&gt; = &lt;input type=&quot;text&quot; v-model=&quot;fullname&quot;&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#box&quot;, data: { firstname: &#39;&#39;, lastname: &#39;&#39;, fullname: &#39;&#39; }, methods: {}, watch: { &#39;firstname&#39;: function (newVal, oldVal) { this.fullname = newVal + &#39;-&#39; + this.lastname; }, &#39;lastname&#39;: function (newVal, oldVal) { this.fullname = this.firstname + &#39;-&#39; + newVal; }, } }); &lt;/script&gt; &lt;/body&gt; 1、watch监视路由的改变通过$route.path 来判断路由的改变。注意不要加 this。 &lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;router-link to=&quot;/login&quot;&gt;登陆&lt;/router-link&gt; &lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; // 3、创建组件模板对象 var login = { template: &#39;&lt;h3&gt;登录组件&lt;/h3&gt;&#39;, }; var register = { template: &#39;&lt;h3&gt;注册组件&lt;/h3&gt;&#39; }; // 2、创建路由对象 var routerObj = new VueRouter({ routes: [{ path: &#39;/&#39;, redirect: &#39;/login&#39; }, { path: &#39;/login&#39;, component: login }, { path: &#39;/register&#39;, component: register }], }); var vm = new Vue({ el: &quot;#box&quot;, data: {}, methods: {}, // 4、将vm实例和路由对象联系起来 router: routerObj, watch: { // 注意不要加 this. &#39;$route.path&#39;: function (newVal, oldVal) { if (newVal === &#39;/register&#39;) { console.log(&#39;注册页面&#39;); } else if (newVal === &#39;/login&#39;) { console.log(&#39;登录页面&#39;); } } } }); &lt;/script&gt; &lt;/body&gt; 2、computed 监视 data数据的改变除了 watch 之外，还有computed这个属性，可以用来监视data上的数据改变。 在 computed 中，可以定义一些 属性，这些属性，叫做 计算属性， 计算属性的本质，就是 一个方法，只不过我们在使用 这些计算属性的时候，是把它们的名称，直接当作属性来使用的，并不会把计算属性，当作方法去调用。 并且在计算属性的这个 function 内部，所用到的任何 data 中的数据，如果这些数据发送了变化，就会调用这个计算属性的 function 函数。 &lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstname&quot;&gt; + &lt;input type=&quot;text&quot; v-model=&quot;lastname&quot;&gt; = &lt;input type=&quot;text&quot; v-model=&quot;fullname&quot;&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#box&quot;, data: { firstname: &#39;&#39;, lastname: &#39;&#39;, }, methods: {}, computed: { &#39;fullname&#39;: function () { return this.firstname + &#39;-&#39; + this.lastname; } } }); &lt;/script&gt; &lt;/body&gt; 在我们的 data 里面就把 fullname去掉了。 然后在 computed 里面，只要firstname 或者 lastname 发生了改变，就会调用 fullname 这个名称的函数，但是 我们在 &lt;input type=&quot;text&quot; v-model=&quot;fullname&quot;&gt; 中，fullname 却不需要加括号()。 3、watch，computed，methods的区别 computed属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用； methods方法表示一个具体的操作，主要书写业务逻辑； watch是一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是computed和methods的结合体；","categories":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}]},{"title":"Gulp","slug":"Gulp","date":"2018-09-09T01:24:39.000Z","updated":"2019-04-09T05:31:04.315Z","comments":true,"path":"2018/09/09/Gulp/","link":"","permalink":"http://fudaqiang.com/2018/09/09/Gulp/","excerpt":"","text":"一、Gulp介绍Gulp 中文主页: http://www.gulpjs.com.cn/ gulp是与grunt功能类似的前端项目构建工具, 也是基于Nodejs的自动任务运行器 。能自动化地完成 javascript/coffee/sass/less/html/image/css 等文件的合并、压缩、检查、监听文件变化、浏览器自动刷新、测试等任务。 gulp比Grunt更加高效，Gulp是基于异步多任务的处理方式，而 Grunt 则是同步的任务处理方式。使得Gulp 更易于使用。 注意：Gulp 也不支持 ES6 语法。 二、Gulp使用步骤由于 Gulp 也是基于 node.js 的，所以首先要确保安装了 node.js. 1、安装 nodejs, 查看版本: node -v 2、创建一个简单的应用 gulp_test 下面为gulp_test项目的目录结构： |- dist ---- 存放项目上线的文件 |- src |- js |- css |- less |- index.html |- gulpfile.js-----gulp配置文件 |- package.json { &quot;name&quot;: &quot;gulp_test&quot;, &quot;version&quot;: &quot;1.0.0&quot; } 3、安装gulp 全局安装gulpnpm install gulp -g 局部安装gulpnpm install gulp --save-dev 4、配置编码:gulpfile.js 注意：gulpfile.js 不需要首字母大写，而 Gruntfile.js 需要首字母大写。 //引入gulp模块 var gulp = require(&#39;gulp&#39;); //定义默认任务 gulp.task(&#39;任务名&#39;, function() { // 将你的任务的任务代码放在这 }); gulp.task(&#39;default&#39;, [&#39;任务&#39;])//异步执行 5、构建命令 gulp 任务名 三、Gulp插件Gulp 同 Grunt 一样，Culp 本身是不会执行任务的，执行任务的都是小弟，也就是gulp下的插件。 注意：查找gulp的插件，需要切换到gulp国外官网，然后点击 plugins 选项，才可以查看查找相关插件。 相关插件: gulp-concat : 合并文件(js/css) gulp-uglify : 压缩js文件 gulp-rename: 文件重命名 gulp-less : 编译less gulp-clean-css : 压缩css gulp-livereload : 实时自动编译刷新 重要API gulp.src(filePath/pathArr) : 指向指定路径的所有文件, 返回文件流对象。用于读取文件。 gulp.dest(dirPath/pathArr) ：指向指定的所有文件夹。用于向文件夹中输出文件。 gulp.task(name, [deps], fn) ：定义一个任务 gulp.watch() ：监视文件的变化 四、插件使用1、合并压缩js1、创建js文件 src/js/test1.js(function () { function add(num1, num2) { return num1 + num2; } console.log(add(10, 30)); })(); src/js/test2.js(function () { var arr = [2,3,4].map(function (item, index) { return item+1; }); console.log(arr); })(); 2、下载相应插件: npm install gulp-concat gulp-uglify gulp-rename --save-dev 3、配置 gulpfile.js // 引入gulp模块 var gulp = require(&quot;gulp&quot;); //引入gulp插件 var concat = require(&quot;gulp-concat&quot;); var uglify = require(&quot;gulp-uglify&quot;); var rename = require(&quot;gulp-rename&quot;); gulp.task(&#39;js&#39;, function () { return gulp.src(&#39;src/js/*.js&#39;) // 引入js源文件 .pipe(concat(&#39;build.js&#39;)) // 合并为临时js文件build.js .pipe(gulp.dest(&#39;dist/js/&#39;)) // 输出到dist/js目录下 .pipe(uglify()) // 将临时js文件压缩 .pipe(rename({ // 将压缩后的js文件添加.min后缀（重命名为build.min.js） suffix: &#39;.min&#39; })) .pipe(gulp.dest(&#39;dist/js/&#39;)); // 再将最终的build.min.js输出到dist/js目录下 }); gulp.task(&#39;default&#39;, [&#39;js&#39;]); 1、插件的引入不同于gulp模块的引入，gulp 的引入之后，gulp是个对象，可以点出task等任务，但是插件引入之后是个方法，既然是方法，就可以直接加括号来调用，此为区别，需要注意。 2、gulp.src 引入源文件的时候，如果 js目录 下面还有目录，这个目录里面也有js文件，如果想递归引入src里面所有的js可以这样写：src/js/**/*.js ，给 js 目录下面套上一个 ** 目录就递归查找 js目录下所有的js文件。 3、.pipe 是管道操作，用来链接任务的执行流。 4、rename 方法里面可以直接填写 build.min.js 来指定文件名，也可以使用一个对象，其键为 suffix 表示后缀名的意思，值为 .min 表示后缀名为 .min，但是这里面的后缀名是除开 .js 后缀的，最后在文件名的最后还会加上.js的。 5、return 的作用：使得grup的任务执行为异步的，就这一点，非常重要。 4、页面引入 js 浏览测试 &lt;script type=&quot;text/javascript&quot; src=&quot;dist/js/built.min.js&quot;&gt;&lt;/script&gt; 2、合并压缩css/less1、创建less/css文件 src/css/test1.css#div1 { width: 100px; height: 100px; background: green; } src/css/test2.css#div2 { width: 200px; height: 200px; background: blue; } src/less/test3.less@base: yellow; .index1 { color: @base; } .index2 { color: green; } 2、下载插件 npm install gulp-less gulp-clean-css --save-dev 3、配置gulpfile.js var less = require(&#39;gulp-less&#39;); var cleanCSS = require(&#39;gulp-clean-css&#39;); //less处理任务 gulp.task(&#39;lessTask&#39;, function () { return gulp.src(&#39;src/less/*.less&#39;) .pipe(less()) .pipe(gulp.dest(&#39;src/css/&#39;)); }) //css处理任务, 指定依赖的任务 gulp.task(&#39;cssTask&#39;,[&#39;lessTask&#39;], function () { return gulp.src(&#39;src/css/*.css&#39;) .pipe(concat(&#39;built.css&#39;)) .pipe(gulp.dest(&#39;dist/css/&#39;)) .pipe(rename({suffix: &#39;.min&#39;})) .pipe(cleanCSS({compatibility: &#39;ie8&#39;})) // 为了兼容IE8浏览器 .pipe(gulp.dest(&#39;dist/css/&#39;)); }); gulp.task(&#39;default&#39;, [&#39;minifyjs&#39;, &#39;cssTask&#39;]); 有个问题： 1、我们知道，grup是异步执行的，那么上面的 less任务和 css任务会异步执行，但是有这个情况就是 less任务量非常大，事件消耗长，而css任务很小，那么有可能 css执行完了 less还没有执行完，也就没有生成 css 任务需要的 css文件，这个时候 css的任务执行就没有包括 less生成的 css文件，相当于 less的任务白做了。 2、所以，为了保证任务的执行先后，grup也可以同步执行，在gulp.task中传入一个数组，里面是处理当前任务所要依赖的任务，只有依赖的任务完成之后，才会执行当前任务。 3、所以，grup其实可以同步可以异步，但是它的异步才是它最大的卖点。 4、页面引入css测试 &lt;link rel=&quot;stylesheet&quot; href=&quot;dist/css/built.min.css&quot;&gt; &lt;div id=&quot;div1&quot; class=&quot;index1&quot;&gt;div1111111&lt;/div&gt; &lt;div id=&quot;div2&quot; class=&quot;index2&quot;&gt;div2222222&lt;/div&gt; 3、压缩html1、下载插件 npm install gulp-htmlmin --save-dev 2、配置gulpfile.js var htmlmin = require(&#39;gulp-htmlmin&#39;); //压缩html任务 gulp.task(&#39;htmlMinify&#39;, function() { return gulp.src(&#39;index.html&#39;) .pipe(htmlmin({collapseWhitespace: true})) // 去除多余的空格 .pipe(gulp.dest(&#39;dist/&#39;)); }); gulp.task(&#39;default&#39;, [&#39;minifyjs&#39;, &#39;cssTask&#39;, &#39;htmlMinify&#39;]); 3、修改页面引入路径 &lt;link rel=&quot;stylesheet&quot; href=&quot;css/built.min.css&quot;&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/built.min.js&quot;&gt;&lt;/script&gt; 4、半自动编译我们在 grunt 中有个watch插件，可以实时监视源文件的变化，那么在 gulp中也有类似的插件，叫做gulp-livereload 。 1、下载插件 npm install gulp-livereload --save-dev 2、配置gulpfile.js var livereload = require(&#39;gulp-livereload&#39;); //每个任务的最后都应该加上下面这一句 .pipe(livereload()); gulp.task(&#39;watch&#39;, [&#39;default&#39;], function () { //开启监视 livereload.listen(); //监视指定的文件, 并指定对应的处理任务 gulp.watch(&#39;src/js/*.js&#39;, [&#39;minifyjs&#39;]) gulp.watch([&#39;src/css/*.css&#39;,&#39;src/less/*.less&#39;], [&#39;cssTask&#39;,&#39;lessTask&#39;]); }); 注意： 1、watch 任务执行代码，一定要先执行 default 任务，也就是要把 default 作为 watch 任务的依赖。 2、在default里的每个任务的最后要接一个管道.pipe(livereload());来保证源文件修改后执行watch任务后，重新刷新到页面。 5、全自动编译上面半自动编译的过程，我们可以看到在我们对源码编译保存后，还需要手动刷新浏览器，能不能在我修改源文件保存后自动刷新到浏览器显示呢？ 1、下载插件gulp-connect npm install gulp-connect --save-dev 2、配置 gulpfile.js var connect = require(&quot;gulp-connect&quot;); //每个任务的最后都应该加上下面这一句 .pipe(connect.reload()); // 全自动任务 gulp.task(&#39;server&#39;, [&#39;default&#39;], function () { connect.server({ // 最后要生成的源文件的路径 root: &#39;dist/&#39;, // 开启实时刷新 livereload: true, // 开启服务器的端口号 port: 1000 }); // 监视的源文件 gulp.watch(&#39;src/js/*.js&#39;, [&#39;js&#39;]); gulp.watch([&#39;src/css/*.css&#39;, &#39;src/less/*.less&#39;], [&#39;css&#39;]); }); 问题：每次我还是要复制链接http://localhost:1000/ 到浏览器打开网页查看，还是很麻烦哦，能不能自动打开网页？^_^ 0.o 额你也太懒了….不过我还是有办法解决的。 1、下载插件：open npm install open --save-dev 2、配置（只需要加上一句open(你的链接);） var open = require(&quot;open&quot;); gulp.task(&#39;server&#39;, [&#39;default&#39;], function () { connect.server({ // 最后要生成的源文件的路径 root: &#39;dist/&#39;, // 开启实时刷新 livereload: true, // 开启服务器的端口号 port: 1000 }); // 自动打开链接 open(&quot;http://localhost:1000/&quot;); // 监视的源文件 gulp.watch(&#39;src/js/*.js&#39;, [&#39;js&#39;]); gulp.watch([&#39;src/css/*.css&#39;, &#39;src/less/*.less&#39;], [&#39;css&#39;]); }); 五、插件打包加载插件打包加载的好处是，我们不需要每次在 gulpfile.js 的开始定义插件的方法，而是用一个对象，这个对象的属性中包含所有用到的插件的方法。 1、将所有需要的插件都下载好。 npm install gulp-concat gulp-uglify gulp-rename gulp-clean-css gulp-connect gulp-htmlmin gulp-less gulp-livereload open --save-dev 2、下载打包插件： gulp-load-plugins npm install gulp-load-plugins --save-dev 3、在gulpfile.js引入 var $ = require(&#39;gulp-load-plugins&#39;)(); 注意：引入的插件是个方法，调用之后的返回值就是我们需要的对象，这个对象中包含之前引入的所有插件的方法，以后用到哪个插件的方法，直接使用 $.方法 的方式即可。 var gulp = require(&quot;gulp&quot;); var $ = require(&quot;gulp-load-plugins&quot;)(); // var concat = require(&quot;gulp-concat&quot;); // var uglify = require(&quot;gulp-uglify&quot;); // var rename = require(&quot;gulp-rename&quot;); // var less = require(&quot;gulp-less&quot;); // var cleanCss = require(&quot;gulp-clean-css&quot;); // var htmlmin = require(&quot;gulp-htmlmin&quot;); // var livereload = require(&quot;gulp-livereload&quot;); // var connect = require(&quot;gulp-connect&quot;); var open = require(&quot;open&quot;); // 合并压缩js gulp.task(&#39;js&#39;, function () { return gulp.src(&#39;src/js/*.js&#39;) .pipe($.concat(&#39;build.js&#39;)) .pipe(gulp.dest(&#39;dist/js/&#39;)) .pipe($.uglify()) .pipe($.rename({ suffix: &#39;.min&#39; })) .pipe(gulp.dest(&#39;dist/js/&#39;)) .pipe($.livereload()) .pipe($.connect.reload()); }); // less编译为css gulp.task(&#39;less&#39;, function () { return gulp.src(&quot;src/less/*.less&quot;) .pipe($.less()) .pipe(gulp.dest(&quot;src/css/&quot;)) .pipe($.livereload()) .pipe($.connect.reload()); }); // css合并压缩 gulp.task(&#39;css&#39;, [&#39;less&#39;], function () { return gulp.src(&#39;src/css/*.css&#39;) .pipe($.concat(&quot;build.css&quot;)) .pipe(gulp.dest(&#39;dist/css/&#39;)) .pipe($.cleanCss({ compatibility: &#39;ie8&#39; })) .pipe($.rename({ suffix: &#39;.min&#39; })) .pipe(gulp.dest(&#39;dist/css/&#39;)) .pipe($.livereload()) .pipe($.connect.reload()); }); // html压缩 gulp.task(&#39;html&#39;, function () { return gulp.src(&#39;index.html&#39;) .pipe($.htmlmin({ collapseWhitespace: true })) .pipe(gulp.dest(&#39;dist/&#39;)) .pipe($.livereload()) .pipe($.connect.reload()); }); // 半自动编译 gulp.task(&#39;watch&#39;, [&#39;default&#39;], function () { $.livereload.listen(); gulp.watch(&#39;src/js/*.js&#39;, [&#39;js&#39;]); gulp.watch([&#39;src/css/*.css&#39;, &#39;src/less/*.less&#39;], [&#39;css&#39;]); }); // 全自动编译 gulp.task(&#39;server&#39;, [&#39;default&#39;], function () { $.connect.server({ // 最后要生成的源文件的路径 root: &#39;dist/&#39;, // 开启实时刷新 livereload: true, // 开启服务器的端口号 port: 1000 }); // 自动打开链接 open(&quot;http://localhost:1000/&quot;); // 监视的源文件 gulp.watch(&#39;src/js/*.js&#39;, [&#39;js&#39;]); gulp.watch([&#39;src/css/*.css&#39;, &#39;src/less/*.less&#39;], [&#39;css&#39;]); }); gulp.task(&#39;default&#39;, [&#39;js&#39;, &#39;less&#39;, &#39;css&#39;, &#39;html&#39;]); 注意： 1、gulp-load-plugins 中没有 open 方法，open插件需要单独引入。 2、$ 包含的方法有个规律，就是它的方法的命名一般都是插件的除去grup的剩下单词的组合，比如 gulp-rename 插件对应的方法，在$对象中就是 $.less ，gulp-clean-css 插件比较特殊，因为后面两个单词，所以在 $ 中的方法遵循驼峰命名法，就是 $.cleanCss 。","categories":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}]},{"title":"vuex","slug":"vuex","date":"2018-08-09T05:24:15.000Z","updated":"2019-04-09T05:49:15.579Z","comments":true,"path":"2018/08/09/vuex/","link":"","permalink":"http://fudaqiang.com/2018/08/09/vuex/","excerpt":"","text":"​ 一、VuexVuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态（意思就是数据），并以相应的规则保证状态以一种可预测的方式发生变化。 简单来说，vuex就是用来集中管理组件的数据的。 二、Vuex使用场合如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的 store 模式就足够您所需了。但是，如果您需要构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。引用 Redux 的作者 Dan Abramov 的话说就是： Flux 架构就像眼镜：您自会知道什么时候需要它。 1、store模式安装vuex npm i vuex -S 我们在原有项目下新建一个store.js管理Home，Goods，Users组件的数据。 其中state属性就是保存Home，Goods，Users组件所有的数据。 // store.js import Vue from &#39;vue&#39; import Vuex from &#39;vuex&#39; Vue.use(Vuex); const store = new Vuex.Store({ state: { title: &#39;首页&#39;, goodsList: [ { goodsName: &#39;苹果&#39;, price: 20 }, { goodsName: &#39;橘子&#39;, price: 22 }, { goodsName: &#39;香蕉&#39;, price: 50 }, { goodsName: &#39;菠萝&#39;, price: 43 }, ], userList: [ { userName: &#39;lvonve&#39;, age: 18 }, { userName: &#39;daotin&#39;, age: 19 }, { userName: &#39;wenran&#39;, age: 17 }, ] } }); export { store } 注意：将store.js文件导入到vue实例中： new Vue({ el: &quot;#app&quot;, components: { App }, template: `&lt;App /&gt;`, router, store }) 然后各个组件在获取数据的时候，是在computed属性中获取的，例如User组件（我们在user组件也把所有的数据都显示出来吧）： 获取的方式通过this.$store.state 的方式获取。 export let Users = { template: require(&#39;./index.html&#39;), // data() { // return { // users: [ // { name: &#39;lvonve&#39; }, // { name: &#39;daotin&#39; }, // { name: &#39;wenran&#39; }, // ] // } // }, computed: { // 这个userList就是获取到的state中的userList title: function() { return this.$store.state.title; }, userList: function() { return this.$store.state.userList; }, goodsList: function() { return this.$store.state.goodsList; } } } 然后在user组件进行显示： &lt;div&gt; &lt;h1&gt;{{title}}&lt;/h1&gt; &lt;h4&gt;用户列表&lt;/h4&gt; &lt;ul&gt; &lt;li v-for=&quot;user in userList&quot;&gt;{{user.userName}}+{{user.age}}&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;商品列表&lt;/h4&gt; &lt;ul&gt; &lt;li v-for=&quot;goods in goodsList&quot;&gt;{{goods.goodsName}}+{{goods.price}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 但是现在有个不好的地方就是，每个组件都需要使用this.$store.state来获取其中的数据，显得有些麻烦，有没有简单的办法呢？ 2、mapStatevuex提供了一个工具叫做mapState，通过它可以简化我们获取数据的方式。 mapState的作用就是返回一个对象，这个对象可以直接丢给computed。所以上面获取state的数据的方式可以写成下面的方式： import { mapState } from &#39;vuex&#39; export let Users = { template: require(&#39;./index.html&#39;), // computed: { // userList: function() { // return this.$store.state.userList; // }, // goodsList: function() { // return this.$store.state.goodsList; // } // } computed: mapState({ title(state) { return state.title; }, userList(state) { return state.userList; }, goodsList(state) { return state.goodsList; } }), } 或者你想要更简单，可以使用ES6的解构赋值： computed: mapState({ title: ({ title }) =&gt; title, userList: ({ userList }) =&gt; userList, goodsList: ({ goodsList }) =&gt; goodsList, }), 还有更简单的写法：如果state上有某个属性，可以直接赋值： computed: mapState({ title: &#39;title&#39;, userList: &#39;userList&#39;, goodsList: &#39;goodsList&#39; }), 终极写法，就是如果mapState属性的名字和state中属性的名字相同的话，就可以采用下面更简单的写法： （我们上面的例子就是mapState属性的名字和state中属性的名字相同） computed: mapState([&#39;title&#39;, &#39;goodsList&#39;, &#39;userList&#39;]) mapState使用展开符写法 一个项目中，有些时候有些mapState属性的名字和state中属性的名字相同，有些又不相同，比如下面的例子： computed: mapState({ title: &#39;title&#39;, users: &#39;userList&#39;, goods: &#39;goodsList&#39; }), 受到users和goods的拖累，title也不能写成终极进化版，这时候可以使用展开符。 ...mapState([&#39;title&#39;]) // 就类似于 mapState({ title:&#39;title&#39; }) 所以上面的例子的最终写法为： computed: { ...mapState([&#39;title&#39;]), ...mapState({ users: &#39;userList&#39;, goods: &#39;goodsList&#39; }) }, 由于我们的babel只能编译基础的ES6语法，展开符是高级ES6语法，所以还要安装一个模块： npm i babel-preset-stage-2 -D 然后在.babelrc 里面添加： { &quot;presets&quot;: [ &quot;env&quot;, &quot;stage-2&quot; ] } 使用展开符的写法还有一个好处就是可以写自己的computed计算属性，而终极写法是没办法加自己的计算属性的。所以展开符的写法是最灵活的写法。 3、mutations修改state现在有个新需求，在user组件，点击按钮，添加一个新用户（先把没用的商品列表去掉），我门一般的想法是直接操作state数据，如下： methods: { addUser() { this.$store.state.userList.push({userName: &#39;aaa&#39;,age: 9}) } } 但是这种写法是不符合store架构规范的，只能通过store提供的mutations来操作自己的state。所以我们在store中定义一个mutations属性，然后这个属性中定义一个addUser方法来添加用户，这个方法的参数指向的就是store的state属性： import Vue from &#39;vue&#39; import Vuex from &#39;vuex&#39; Vue.use(Vuex); const store = new Vuex.Store({ state: { title: &#39;我是title&#39;, goodsList: [ { goodsName: &#39;苹果&#39;, price: 20 }, { goodsName: &#39;橘子&#39;, price: 22 }, { goodsName: &#39;香蕉&#39;, price: 50 }, { goodsName: &#39;菠萝&#39;, price: 43 }, ], userList: [ { userName: &#39;lvonve&#39;, age: 18 }, { userName: &#39;daotin&#39;, age: 19 }, { userName: &#39;wenran&#39;, age: 17 }, ] }, // 添加mutations属性用来操作state数据 mutations: { addUser(state) { state.userList.push({ userName: &#39;aaa&#39;, age: 10 }); } } }); export { store } 然后在User.js中怎么调用这个addList方法呢？ 使用this.$store.commit(&#39;mutations的属性名&#39;)来调用： import { mapState } from &#39;vuex&#39; export let Users = { template: require(&#39;./index.html&#39;), computed: { ...mapState([&#39;title&#39;, &#39;userList&#39;, &#39;goodsList&#39;]) }, methods: { addUser() { // 使用commit的方式调用 this.$store.commit(&#39;addUser&#39;); } }, } 这样就可以点击按钮添加用户了。 整个应用程序，只有mutations才可以操作state状态。 但是注意： mutations中的属性，必须为纯函数，必须为同步代码。 纯函数就是传入相同的参数，得到相同的结果。 同步代码就不能是异步的，比如ajax，比如setTimeout等。 修改state时传参我们现在希望添加的用户信息自定义怎么向addUser传递参数呢？ 我们在commit的第二个参数传递数据。这里有个专业的术语叫做【载荷】 import { mapState } from &#39;vuex&#39; export let Users = { template: require(&#39;./index.html&#39;), data() { return { name: &#39;&#39;, age: 0 } }, computed: { ...mapState([&#39;title&#39;, &#39;userList&#39;, &#39;goodsList&#39;]) }, methods: { addUser() { // commit的第二个参数填写传递的载荷 this.$store.commit(&#39;addUser&#39;, { name: this.name, age: this.age }); } }, } 在store里面addUser的第二个参数接收数据： import Vue from &#39;vue&#39; import Vuex from &#39;vuex&#39; Vue.use(Vuex); const store = new Vuex.Store({ state: { title: &#39;我是title&#39;, goodsList: [ { goodsName: &#39;苹果&#39;, price: 20 }, { goodsName: &#39;橘子&#39;, price: 22 }, { goodsName: &#39;香蕉&#39;, price: 50 }, { goodsName: &#39;菠萝&#39;, price: 43 }, ], userList: [ { userName: &#39;lvonve&#39;, age: 18 }, { userName: &#39;daotin&#39;, age: 19 }, { userName: &#39;wenran&#39;, age: 17 }, ] }, mutations: { // data接收commit的载荷 addUser(state, data) { state.userList.push({ userName: data.name, age: data.age }); } } }); export { store } 3、actions除了state和mutations，store还有一个属性叫做actions。 actions里面放的就是mutations不能放的非纯函数，异步函数等。 actions里面的方法，第一个参数不是指向state，而知指向store，第二个参数还是载荷。 需要注意的是，能操作state的只有mutations，actions也不行。只能调用mutations去操作state。 举个例子，这里我们还是添加user，不过是间隔3s才写入state。 actions: { // 第一个参数指向store // 第二个参数还是载荷 addUserTimeout(cStore, data) { setTimeout(() =&gt; { cStore.commit(&#39;addUser&#39;, data); }, 3000); } } 然后在调用的时候就不能使用commit了，而是使用dispatch ： methods: { addUser() { this.$store.commit(&#39;addUser&#39;, { name: this.name, age: this.age }); }, addUserTimeout() { // 使用dispatch调用actions的属性 this.$store.dispatch(&#39;addUserTimeout&#39;, { name: this.name, age: this.age }); } }, 总结mutations与actiosn的区别： 1、commit方法用于调用mutation；dispatch 方法用于调用action； 2、mutation 函数必须是纯函数，而且不能有异步代码；action 可以不是纯函数，也可以有异步代码； 3、按照上述规则，可以用mutation完成的事情，可以直接调用mutation，mutation不能实现的事情丢给action来完成。 4、在action中，当完成异步操作，最终需要修改数据模型时，还是需要通过mutation来完成对数据模型的操作。action不允许直接操作数据模型。 4、gettersstore还有一个属性getters，相当于store的一个计算属性，就是对state的数据进行计算，当组件需要取到state的属性然后进行计算得到想要的结果的时候，计算的过程可以在getters 中进行，组件从getters中就可以直接拿到计算好的值。 这样还有一个好处就是，不仅当前组件可以拿个计算好的值，所有组件都可以拿到，如果所有组件都需要这个计算的话，那就方便多了。 举个例子：我们获取所有用户age之和： getters: { countAge(state) { let num = 0; state.userList.map(user =&gt; { num += user.age; }) return num; } } 然后在user组件里面： computed: { ...mapState([&#39;title&#39;, &#39;userList&#39;, &#39;goodsList&#39;]), // 直接调用getters的countAge属性即可 allAge() { return this.$store.getters.countAge } }, 然后页面：&lt;div&gt;age之和：&lt;/div&gt; 就会显示所有用户age之和。 和获取state值一样类似，每次获取getters的值都要使用this.$store.getters 的方式很麻烦，所以类似mapState还有mapGetters,写法和mapState一样： computed: { ...mapState([&#39;title&#39;, &#39;userList&#39;, &#39;goodsList&#39;]), ...mapGetters({ allAge: &#39;countAge&#39; }), // allAge() { // return this.$store.getters.countAge // } }, 实际上，除了有mapState，mapActions，mapMutations，mapGetters都有，且用法相同。 我们将user组件进行进行改造： methods: { // addUser() { // this.$store.commit(&#39;addUser&#39;, { // name: this.name, // age: this.age // }); // }, // addUserTimeout() { // console.log(&#39;user&#39;, this.name, this.age); // this.$store.dispatch(&#39;addUserTimeout&#39;, { // name: this.name, // age: this.age // }); // }, // 改造一 ...mapMutations({ addUser: &#39;addUser&#39; }), ...mapActions({ addUserTimeout: &#39;addUserTimeout&#39; }), // 改造二 ...mapMutations([&#39;addUser&#39;]), ...mapActions([&#39;addUserTimeout&#39;]), }, 上面的写法有个问题就是没法传递载荷？ 那么载荷在哪里传递呢？在视图中绑定点击事件时传递： 给事件加上参数，这个参数就是载荷。 &lt;div&gt; &lt;h1&gt;{{title}}&lt;/h1&gt; &lt;h4&gt;用户列表&lt;/h4&gt; &lt;div&gt;用户名：&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;&lt;/div&gt; &lt;div&gt;年龄：&lt;input type=&quot;text&quot; v-model.number=&quot;age&quot;&gt;&lt;/div&gt; &lt;!-- 原始的只有函数名 --&gt; &lt;!-- &lt;button @click=&#39;addUser&#39;&gt;添加用户&lt;/button&gt; --&gt; &lt;!-- &lt;button @click=&#39;addUserTimeout&#39;&gt;间隔3s添加用户&lt;/button&gt; --&gt; &lt;!-- 改造一 --&gt; &lt;!-- &lt;button @click=&#39;addUser({name:name,age:age})&#39;&gt;添加用户&lt;/button&gt; &lt;button @click=&#39;addUserTimeout({name:name,age:age})&#39;&gt;间隔3s添加用户&lt;/button&gt; --&gt; &lt;!-- 改造二 --&gt; &lt;button @click=&#39;addUser({name,age})&#39;&gt;添加用户&lt;/button&gt; &lt;button @click=&#39;addUserTimeout({name,age})&#39;&gt;间隔3s添加用户&lt;/button&gt; &lt;ul&gt; &lt;li v-for=&quot;user in userList&quot;&gt;{{user.userName}}+{{user.age}}&lt;/li&gt; &lt;/ul&gt; &lt;div&gt;age之和：{{allAge}}&lt;/div&gt; &lt;/div&gt; 三、store拆分如果组件特别多，每个组件的数据也就特别多，我们希望对这些数据根据不同的组件进行拆分方便管理。 现在有Home和User组件，Home组件的数据放在Home的store里面，User的数据放在User的store里面。 分别为homeStore.js和userStore.js，然后还有一个合并一起的主store叫index.js。 我们在home组件就显示一个title，user组件还是显示之前的内容。 // homeStore.js export default { state: { title: &#39;我是首页&#39;, } } // userStore.js export default { state: { title: &#39;我是用户页&#39;, userList: [ { userName: &#39;lvonve&#39;, age: 18 }, { userName: &#39;daotin&#39;, age: 19 }, { userName: &#39;wenran&#39;, age: 17 }, ] }, mutations: { addUser(state, data) { state.userList.push({ userName: data.name, age: data.age }); } }, actions: { // 第一个参数指向store // 第二个参数还是载荷 addUserTimeout(cStore, data) { setTimeout(() =&gt; { cStore.commit(&#39;addUser&#39;, data); }, 3000); } }, getters: { countAge(state) { let num = 0; state.userList.map(user =&gt; { num += user.age; }) return num; } } } 然后主store，index.js： 通过modules属性来注入各个子store import Vue from &#39;vue&#39; import Vuex from &#39;vuex&#39; import homeStore from &#39;./homeStore&#39; import userStore from &#39;./userStore&#39; Vue.use(Vuex); const store = new Vuex.Store({ modules: { home: homeStore, user: userStore } }); export { store } 然后在main.js里面vue实例中注入的就不是原先的store.js而是index.js。 由于store下的主store名字是index.js，所以不需要修改，但是要重启服务。 import Vue from &#39;vue&#39; import { router } from &#39;./router&#39; import { store } from &#39;./store&#39; import { App } from &#39;./App&#39; new Vue({ el: &#39;#app&#39;, template: &#39;&lt;App/&gt;&#39;, components: { App }, router, store }); 然后在Home.js和User.js显示这些数据： // Home.js import { mapState, mapMutations, mapActions, mapGetters } from &#39;vuex&#39; export let Home = { template: require(&#39;./index.html&#39;), computed: { ...mapState([&#39;title&#39;]) } } //User.js import { mapState, mapMutations, mapActions, mapGetters } from &#39;vuex&#39; export let Users = { template: require(&#39;./index.html&#39;), data() { return { name: &#39;&#39;, age: 0 } }, computed: { ...mapState([&#39;title&#39;, &#39;userList&#39;, &#39;goodsList&#39;]), ...mapGetters({ allAge: &#39;countAge&#39; }), }, methods: { ...mapMutations([&#39;addUser&#39;]), ...mapActions([&#39;addUserTimeout&#39;]), }, } 但是我们发现一个问题就是Home.js中的： computed: { ...mapState([&#39;title&#39;]) } 拿不到title的值，为什么呢？上面的写法相当于： computed: { ...mapState({ //title:&#39;title&#39; title: (state)=&gt;state.title; }) } 但是我们现在state里面还title吗，没有了state.home下才有title。 所以，令人沮丧的是，如果使用了store拆分，就不能使用展开符的写法了。 正确的写法是： computed: { ...mapState({ title: (state) =&gt; state.home.title; }) } User.js也是一样的。 注意： 但是对于mutations，actions，getters不会区分home和user，都会集合到一起，类似于全局的属性，所欲的组件都可以访问到，所以也就不需要加home和user前缀。 1、namespaced命名空间但是可能会存在这样一个问题，就是home和user下的mutations或者actions或者getters都有一个叫做add的方法，那么在调用的时候，调用的是谁的add呢？命名会冲突吗？ 我们可以在子store里面加一句话： namespaced:true 开启命名空间。 // homeStore.js export default { // 开启命名空间 namespaced: true, state: { title: &#39;我是首页&#39;, } } 然后获取的这些方法的时候就要加前缀home或者user： // User.js import { mapState, mapMutations, mapActions, mapGetters } from &#39;vuex&#39; export let Users = { template: require(&#39;./index.html&#39;), data() { return { name: &#39;&#39;, age: 0 } }, computed: { ...mapState({ title: (state) =&gt; state.user.title, userList: (state) =&gt; state.user.userList }), // 加user前缀 ...mapGetters({ allAge: &#39;user/countAge&#39; }), }, methods: { // 加user前缀 ...mapMutations({ addUser: &#39;user/addUser&#39; }), ...mapActions({ addUserTimeout: &#39;user/addUserTimeout&#39; }), }, } 然后还有一种写法如下，效果一样： 就是把前缀路径‘user/’提到第一个参数的位置，后面的写法和以前相同。 computed: { ...mapState({ title: (state) =&gt; state.user.title, userList: (state) =&gt; state.user.userList }), // &#39;user/&#39;提前 ...mapGetters(&#39;user/&#39;, { allAge: &#39;countAge&#39; }), }, methods: { // &#39;user/&#39;提前 ...mapMutations(&#39;user/&#39;, [&#39;addUser&#39;]), ...mapActions(&#39;user/&#39;, [&#39;addUserTimeout&#39;]), },","categories":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}]},{"title":"严格模式","slug":"严格模式","date":"2018-06-08T14:16:33.000Z","updated":"2019-04-09T05:32:51.158Z","comments":true,"path":"2018/06/08/严格模式/","link":"","permalink":"http://fudaqiang.com/2018/06/08/严格模式/","excerpt":"","text":"一、ECMAScript 5 严格模式1、概述除了正常运行模式，ECMAscript 5添加了第二种运行模式：”严格模式”（strict mode）。顾名思义，这种模式使得Javascript在更严格的条件下运行。 2、目的 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的Javascript做好铺垫。 “严格模式”体现了Javascript更合理、更安全、更严谨的发展方向，包括IE 10在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱它。 另一方面，同样的代码，在”严格模式”中，可能会有不一样的运行结果；一些在”正常模式”下可以运行的语句，在”严格模式”下将不能运行。掌握这些内容，有助于更细致深入地理解Javascript，让你变成一个更好的程序员。 3、使用1、将”use strict”放在脚本文件的第一行，则整个脚本都将以”严格模式”运行。如果这行语句不在第一行，则无效，整个脚本以”正常模式”运行。如果不同模式的代码文件合并成一个文件，这一点需要特别注意。 (严格地说，只要前面不是产生实际运行结果的语句，”use strict”可以不在第一行，比如直接跟在一个空的分号后面。) &lt;script&gt; &quot;use strict&quot;; //... &lt;/script&gt; 2、针对单个函数 将”use strict”放在函数体的第一行，则整个函数以”严格模式”运行。 function strict(){ &quot;use strict&quot;; return &quot;这是严格模式。&quot;; } 二、语法和行为改变1、全局变量必须用var显示声明变量在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。 &lt;script type=&quot;text/javascript&quot;&gt; &quot;use strict&quot;; v = 1; // 报错，v未声明 //name = &quot;Daotin&quot;; for (i = 0; i &lt; 2; i++) { // 报错，i未声明 } &lt;/script&gt; 不能使用 name，因为 name 是window的一个保留属性，默认为空。 2、禁止自定义的函数中的this指向window &lt;script&gt; &quot;use strict&quot;; function foo() { console.log(this); } foo(); &lt;/script&gt; 没有 “use strict” 的时候，打印 window对象，有 “use strict” 的时候，打印undefined。 3、严格模式会创建eval作用域eval会解析语句中的字符串。 &lt;script&gt; &quot;use strict&quot;; var name = &#39;Daotin&#39;; eval(&#39;var name = &quot;lvonve&quot;; console.log(name)&#39;); console.log(name); &lt;/script&gt; 如果不加 “use strict”; ，两次打印的结构都为 lvonve；加了的话，打印结果为 lvonve和Daotin。也就相当于给eval创建了一个作用域。 4、对象不能有重名的属性正常模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。 （但是在浏览器console下面并没有显示错误信息。） &lt;script&gt; &quot;use strict&quot;; var o = { p: 1, p: 2 }; // 语法错误 &lt;/script&gt; 5、禁止删除变量严格模式下无法删除变量。只有configurable设置为true的对象属性，才能被删除。 &quot;use strict&quot;; var x; delete x; // 语法错误 var o = Object.create(null, {&#39;x&#39;: { value: 1, configurable: true }}); delete o.x; // 删除成功","categories":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}]},{"title":"vue路由","slug":"vue路由","date":"0208-12-01T05:36:46.000Z","updated":"2019-04-09T05:42:58.609Z","comments":true,"path":"0208/12/01/vue路由/","link":"","permalink":"http://fudaqiang.com/0208/12/01/vue路由/","excerpt":"","text":"示例文件接到 Vue的组件 一、Vue路由1、什么是路由？后端路由：对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源； 前端路由：对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，并不会向后端发送请求。同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现； 在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）； 承接到Vue的组件的示例文件：👇 现在有Home，Goods和Users子组件，我们在点击跳转按钮的时候，页面通过&lt;Component :is=&quot;currentPage&quot; /&gt; 改变了，但是地址url没变，这就是单页面应用。 这样有一个问题就是没法分享给他人，因为地址是相同的，但是看到的内容不同。还有一点就是没有回退功能。 如何解决这个问题？及用到了vue的路由。 2、路由的基本使用在vue中使用路由需要用到vue-router的插件。 1、按照vue-router插件 npm i vue-router -S 2、引入并注入路由到vue import Router from &#39;vue-router&#39; Vue.use(Router); 3、创建一个路由实例，参数为一个对象，这个配置对象中有一个属性：routes，表示 路由的匹配规则。 let router = new Router({ routes : [ { path: &#39;/home&#39;, component: Home }, //当地址为/home时，显示Home组件 { path: &#39;/goods&#39;, component: Goods }, { path: &#39;/users&#39;, component: Users } ] }); routes 属性是一个数组，数组中的每一项都是一条匹配规则。 每个路由规则，都是一个对象，这个规则对象，身上，有两个必须的属性： path：表示监听的路由链接地址 component：表示如果路由是前面匹配到的 path ，则展示 component 属性对应的那个组件。 4、将路由规则对象router注册到vue实例 new Vue({ el: &quot;#box&quot;, data: {}, methods: {}, // 将路由对象注册到vue实例 router }); 5、一旦路由规则匹配成功，就会在vue-router 提供的标签router-view 上显示出来，这个标签就是匹配路由成功后component对应的组件应该显示的位置。 &lt;div&gt; &lt;button @click=&quot;goPage(nav.name)&quot; v-for=&quot;nav in navs&quot;&gt;{{nav.text}}&lt;/button&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; 然后来看看界面： 3、router-link属性我们之前的超链接是由a标签代替的，如果要跳转那么并且每次href属性都要加上#，这样太麻烦。 vue-router官方提供了一个router-link 的属性可以实现路由的跳转。 &lt;!--app.html--&gt; &lt;div&gt; &lt;router-link tag=&quot;button&quot; :to=&quot;nav.name&quot; v-for=&quot;nav in navs&quot;&gt;{{nav.text}}&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; 我们通过检查可以知道，router-link 会默认渲染为一个a 标签。 但是我们也可以将其改变成别的标签，使用 tag=&quot;span&quot; 属性可以将默认的a标签转换成span标签： &lt;router-link to=&quot;/login&quot; tag=&quot;span&quot;&gt;登陆&lt;/router-link&gt; 4、路由嵌套我们现在想在/home路径下再接子路由a和b，形成嵌套路由/home/a或者/home/b形式的路由。 在路由配置规则数组中使用 children 属性，实现子路由功能。 let router = new Router({ routes: [ // 路由重定向 { path: &#39;/&#39;, redirect: &#39;/home&#39; }, { path: &#39;/home&#39;, component: Home, // 使用children实现子路由 children: [ { path: &#39;a&#39;, component: A }, { path: &#39;b&#39;, component: B } ] }, { path: &#39;/goods&#39;, component: Goods }, { path: &#39;/users&#39;, component: Users } ] }); 注意：子路由的匹配规则前面不要加 / 。 然后在Home的template中加入&lt;router-view&gt;&lt;/router-view&gt;即可。 给路由起别名 我们还可以给路由起个别名，这样在有些路由特别长的时候就很方便。 起别名的方式就是往路由匹配规则加个name属性即可。 let router = new Router({ routes: [ { path: &#39;/&#39;, redirect: &#39;/home&#39; }, { path: &#39;/home&#39;, component: Home, name: &#39;h&#39;, children: [ { path: &#39;a&#39;, component: A, name: &#39;a&#39; }, { path: &#39;b&#39;, component: B, name: &#39;b&#39; } ] }, //当地址为/home时，显示Home组件 { path: &#39;/goods&#39;, component: Goods, name: &#39;g&#39; }, { path: &#39;/users&#39;, component: Users, name: &#39;u&#39; } ] }); 那么我们在使用router-link跳转的时候，属性to就是动态的： &lt;router-link tag=&quot;button&quot; :to=&quot;{name:&#39;a&#39;}&quot; v-for=&quot;nav in navs&quot;&gt;{{nav.text}}&lt;/router-link&gt; 然后重定向redirect也可以使用name： { path: &#39;/&#39;, redirect: {name:&#39;h&#39;} }, 5、多视图路由之前我们是在Home中加载A，B组件，现在有如下需求： 我们在加载/home/one路由的时候，没有名字的router-view加载A组件，有名字的router-view加载B组件； 在加载/home/two路由的时候，没有名字的router-view加载A2组件，有名字的router-view加载B2组件； 这种在Home中显示多个router-view的方式就叫做多视图路由。 首先在Home的template中添加router-view： &lt;div&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;router-view name=&quot;b&quot;&gt;&lt;/router-view&gt; &lt;/div&gt; 接着配置路由： let router = new Router({ routes: [ { path: &#39;/&#39;, redirect: &#39;/home&#39; }, { path: &#39;/home&#39;, component: Home, name: &#39;h&#39;, children: [{ path: &#39;one&#39;, components: { b: B, default: A }, name: &#39;a&#39; }, { path: &#39;two&#39;, components: { b: B2, default: A2 }, name: &#39;b&#39; } ] }, //当地址为/home时，显示Home组件 { path: &#39;/goods&#39;, component: Goods, name: &#39;g&#39; }, { path: &#39;/users&#39;, component: Users, name: &#39;u&#39; } ] }); 由于一个router-view要加载的有两个路由，所以component变成components，复数，然后是个对象，有name=b的就是b：B组件，没有name的就是default：A组件。 演示： 6、编程式导航编程式导航就是通过js来实现页面跳转（之前都是通过标签router-link来跳转的），比如如果用户登录成功跳转道首页，这个判断的功能只能通过js来实现。 我在app.html添加一个按钮： &lt;button @click=&#39;goHome&#39;&gt;跳转到首页&lt;/button&gt; 然后在app.js里面实现点击事件： 通过父组件.$router.push(&#39;路由地址&#39;) 或者是父组件.$router.push({name:&#39;路由别名&#39;})的方式进行跳转。 methods: { goHome() { this.$router.push(&#39;/home&#39;); this.$router.push({ name: &#39;h&#39; }); } }, this.$router.push和this.$router.replace的区别: push会保留跳转前的地址，而replace不会。通过名字也可以看出端倪。 还有this.$router.go(1) 执行浏览指针的前进或者后退次数。 7、路由高亮显示我们在点击登陆和注册链接的时候，可不可以让被点击的链接高亮显示呢？ 方式一： 我们可以看到在激活的路由上面，会使用一个叫做router-link-active 的类，我们通过修改这个类的属性就可以让这个链接高亮显示了。 .router-link-active { color: red; background-color: yellow; } 方式二： 可以通过路由的构造选项 linkActiveClass 来全局配置需要激活的路由样式。 var routerObj = new VueRouter({ routes: [{ path: &#39;/&#39;, redirect: &#39;/login&#39; }, { path: &#39;/login&#39;, component: login }, { path: &#39;/register&#39;, component: register }], // 自定义路由构造选项 linkActiveClass linkActiveClass: &#39;myClass&#39; }); 8、路由切换添加动画效果既然 router-view 是显示组件的，那么我们可以给 router-view 来添加动画效果： &lt;style&gt; .v-enter, .v-leave-to { opacity: 0; } .v-enter-active, .v-leave-active { transition: opacity 0.5s ease; } &lt;/style&gt; &lt;transition mode=&quot;out-in&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/transition&gt; 9、给路由传递参数方式一：问号传参我们可以在路由中，使用查询字符串的方式给路由传递参数。 &lt;div&gt; &lt;h1&gt;商品列表页面&lt;/h1&gt; &lt;ul&gt; &lt;router-link tag=&#39;li&#39; :to=&quot;{name:&#39;d&#39;,query:{gid:goods.goodsID}}&quot; v-for=&quot;goods in list&quot;&gt; &lt;h4&gt;商品名:{{goods.name}}&lt;/h4&gt; &lt;p&gt;价格:{{goods.price}}&lt;/p&gt; &lt;/router-link&gt; &lt;/ul&gt; &lt;/div&gt; 当然上面传递的方式就类似于传统的问号传参方式。比如 /detail?gid=4 这样的方式传递，如果想写在to里面就用上面的方式。 给路由传递参数后，我们并不需要修改路由匹配规则。 我们给路由传递参数就是为了拿到参数，那么如何获取参数呢？ 在我们的组件模板对象里面，可以使用this.$route.query 的方式获取我们传入的参数对象。 export let Detail = { template : require(&quot;./index.html&quot;), data(){ return { goodsid : 0 } }, // 加载后获取路由参数 mounted(){ let goodsid = this.$route.query.gid this.goodsid = goodsid } } 方式二：路径传参首先在路由匹配规则中，使用占位符代替路由传递时的参数。 path 中的 :newGid表示如果以后路由后面跟内容了，那么内容的属性就是gid。 {path : &#39;/detail/:newGid&#39;,component:Detail,name:&quot;d&quot;}, 然后在传递参数时，就不是用query了，而是params。 &lt;div&gt; &lt;h1&gt;商品列表页面&lt;/h1&gt; &lt;ul&gt; &lt;router-link tag=&#39;li&#39; :to=&quot;{name:&#39;d&#39;,params:{newGid:goods.goodsID}}&quot; v-for=&quot;goods in list&quot;&gt; &lt;h4&gt;商品名:{{goods.name}}&lt;/h4&gt; &lt;p&gt;价格:{{goods.price}}&lt;/p&gt; &lt;/router-link&gt; &lt;/ul&gt; &lt;/div&gt; 这时候，传过去时就不是问号的形式，而是路径的形式，如：/detail/4 获取的时候也不是query而是params，this.$route.params。 export let Detail = { template : require(&quot;./index.html&quot;), data(){ return { goodsid : 0 } }, // 加载后获取路由参数 mounted(){ let newGoodsid = this.$route.params.newGid; this.goodsid = newGoodsid; } } 方式三：编程式导航传参上面的路由传参都是采用to传参，也就是标签传参，怎么使用编程式导航传参？ 其实和to是一样的： this.$router.push({name:&#39;d&#39;,query:{gid:goods.goodsID}}) this.$router.push({name:&#39;d&#39;,params:{newGid:goods.goodsID}}) 10、vue路由守卫什么是路由守卫？简单来说就是路由在跳转之前的验证，当满足条件时才会进行跳转。 路由守卫也称导航守卫，分为全局守卫，路由守卫和组件守卫 10.1、全局守卫注册全局守卫应该在路由模块暴露出去之前定义，使用router.beforeEach(function(to,from,next){})来注册一个全局守卫。 参数： to：代表目标路径对象 from：来源路径对象 next：用于决定是否继续进行跳转。该方法参数有三种情况： 当next()函数不传参数或者传入true的时候 则允许正常跳转； 当next()函数传入false时 会中断跳转(阻止跳转)； 当next()函数中传入路径时或者对象时(比如:{name:’xxx’})则会重定向到指定路径。 定义在router上的路由守卫 ，全局范围内有效，只要有路径跳转就会触发该守卫。 假如我现在从首页/home跳转到/home/two，根据随机数是否大于0.5决定是否跳转： import Vue from &#39;vue&#39; import Router from &#39;vue-router&#39; import { Home } from &#39;./pages/Home&#39; import { Goods } from &#39;./pages/Goods&#39; import { Users } from &#39;./pages/Users&#39; import { A } from &#39;./components/A&#39; import { B } from &#39;./components/B&#39; import { A2 } from &#39;./components/A2&#39; import { B2 } from &#39;./components/B2&#39; Vue.use(Router); let router = new Router({ routes: [ { path: &#39;/&#39;, redirect: &#39;/home&#39; }, { path: &#39;/home&#39;, component: Home, name: &#39;h&#39;, children: [{ path: &#39;one&#39;, components: { b: B, default: A }, name: &#39;a&#39; }, { path: &#39;two&#39;, components: { b: B2, default: A2 }, name: &#39;b&#39; } ] }, //当地址为/home时，显示Home组件 { path: &#39;/goods&#39;, component: Goods, name: &#39;g&#39; }, { path: &#39;/users&#39;, component: Users, name: &#39;u&#39; } ] }); // 当有路由跳转的时候，就会执行这个函数 router.beforeEach(function(to, from, next) { console.log(to, from); let num = Math.random(); console.log(num); next(num &gt; 0.5 ? true : false); }); export { router }; 可以看到只有随机数大于0.5的时候，页面才真正发生了变化，跳转到了/home/two: 我们把路径对象展开可以看到所有有关路径的信息： 全局守卫还有一个router.afterEach(function(to,from){}) ，还是在路由跳转之前执行，它在决定跳转后 以及真正跳转前执行，其中形参 to from同上。 10.2、路由守卫路由守卫就是针对单个路由对象配置的守卫。 假如我在users组件配置路由守卫，那么只有跳转到users路由时才会触发该守卫，跳转到其他路由时不会触发该守卫。 路由守卫的注册写在路由匹配规则数组里面： let router = new Router({ routes: [ //... { path: &#39;/users&#39;, component: Users, name: &#39;u&#39;, beforeEnter: (to, from, next) =&gt; { next(confirm(&#39;Entey Users?&#39;)); } } ] }); 10.3、组件守卫组件守卫是针对单个组件进行监听，在访问到该组件时才会触发。 既然是组件守卫就写在组件里面，这里以进入Home组件为例： export let Home = { template: ` &lt;div&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;router-view name=&quot;b&quot;&gt;&lt;/router-view&gt; &lt;/div&gt; `, // 在路由跳转时,如果会访问到当前组件,则会触发该守卫 beforeRouteEnter(to, from, next) { next(confirm(&#39;Enter Home?&#39;)); }, // 在路由跳转时,如果离开当前组件,则会触发该守卫 beforeRouteLeave (to, from, next) { next(confirm(&#39;Leave Home?&#39;)); }, // 在当前路径下,当路由的参数发生变化时，才会触发该路由守卫 beforeRouteUpdate(to, from, next) { console.log(to.params.path); } } 命名视图实现经典布局什么是命名视图？ 我们之前的 router-view 都是没有名字的，现在我们可以为其指定名称，就是命名视图。 我们要实现的目标是显示标题，侧边栏和主体三部分的经典视图，类似如下的布局： 那么既然要显示三部分，就需要三个 router-view，怎么让每个 router-view显示不同的内容呢？这就需要用到命名视图。 语法： &lt;router-view name=&quot;view1&quot;&gt;&lt;/router-view&gt; 只需要指定一个name属性即可。 经典布局示例： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;!-- 1.引入vue-router文件 --&gt; &lt;script src=&quot;./lib/vue-router-3.0.1.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body, html, h1, h2, h3 { margin: 0; padding: 0; } .header { width: 100%; height: 80px; background-color: red; } .left { float: left; width: 20%; height: 500px; background-color: green; } .right { float: left; width: 80%; height: 500px; background-color: blue; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;router-view name=&quot;leftBanner&quot;&gt;&lt;/router-view&gt; &lt;router-view name=&quot;rightBanner&quot;&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; // 3、创建组件模板对象 var header = { template: &#39;&lt;h1 class=&quot;header&quot;&gt;顶部&lt;/h1&gt;&#39;, }; var left = { template: &#39;&lt;h3 class=&quot;left&quot;&gt;左边侧栏&lt;/h3&gt;&#39; }; var right = { template: &#39;&lt;h3 class=&quot;right&quot;&gt;右边主体&lt;/h3&gt;&#39;, }; // 2、创建路由对象 var router = new VueRouter({ routes: [{ path: &#39;/&#39;, // component 要显示的组件为一个对象，default为默认显示的组件 // leftBanner表示router-view显示名称为leftBanner的组件 // rightBanner表示router-view显示名称为rightBanner的组件 components: { &#39;default&#39;: header, &#39;leftBanner&#39;: left, &#39;rightBanner&#39;: right } }] }); var vm = new Vue({ el: &quot;#box&quot;, data: {}, methods: {}, // 4、将vm实例和路由对象联系起来 router }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 1、首先创建三个组件模板对象，分别用于显示头部，侧边栏，和主体三个部分。 2、在匹配规则里面， component 变成了 components，并且展示多个组件。其中： default为默认显示的组件； leftBanner表示router-view显示名称为leftBanner的组件 rightBanner表示router-view显示名称为rightBanner的组件。 3、为 router-view 指定 components 中显示不同组件的名称。 4、为显示的不同组件添加样式，形成经典布局样式。","categories":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"http://fudaqiang.com/categories/技术/"}]}]}